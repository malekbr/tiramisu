<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tiramisu Optimization Framework: tiramisu::function Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Tiramisu Optimization Framework
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classtiramisu_1_1function.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classtiramisu_1_1function-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tiramisu::function Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A class to represent functions in Tiramisu.  
 <a href="classtiramisu_1_1function.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="core_8h_source.html">core.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a41227e14c97d5e18d85797ea9000a646"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a41227e14c97d5e18d85797ea9000a646">function</a> (std::string name)</td></tr>
<tr class="memdesc:a41227e14c97d5e18d85797ea9000a646"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a function called <code>name</code>.  <a href="#a41227e14c97d5e18d85797ea9000a646">More...</a><br /></td></tr>
<tr class="separator:a41227e14c97d5e18d85797ea9000a646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92b1a049a512671258cf346af4b59ec6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a92b1a049a512671258cf346af4b59ec6">add_context_constraints</a> (const std::string &amp;new_context)</td></tr>
<tr class="memdesc:a92b1a049a512671258cf346af4b59ec6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a set of constraints to the context of the program.  <a href="#a92b1a049a512671258cf346af4b59ec6">More...</a><br /></td></tr>
<tr class="separator:a92b1a049a512671258cf346af4b59ec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e42f31722b17263102734867aaaa71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#af3e42f31722b17263102734867aaaa71">allocate_and_map_buffers_automatically</a> ()</td></tr>
<tr class="memdesc:af3e42f31722b17263102734867aaaa71"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each computation, allocate a buffer and map the computation to that buffer.  <a href="#af3e42f31722b17263102734867aaaa71">More...</a><br /></td></tr>
<tr class="separator:af3e42f31722b17263102734867aaaa71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5662551a604ffea619b3bbe385120d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#af5662551a604ffea619b3bbe385120d8">compute_bounds</a> ()</td></tr>
<tr class="memdesc:af5662551a604ffea619b3bbe385120d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the bounds of each computation.  <a href="#af5662551a604ffea619b3bbe385120d8">More...</a><br /></td></tr>
<tr class="separator:af5662551a604ffea619b3bbe385120d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b176d9eafdba8c8d9aecbb39b9b8654"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a4b176d9eafdba8c8d9aecbb39b9b8654">dump</a> (bool exhaustive) const</td></tr>
<tr class="memdesc:a4b176d9eafdba8c8d9aecbb39b9b8654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump the function on standard output (dump most of the fields of <a class="el" href="classtiramisu_1_1function.html" title="A class to represent functions in Tiramisu. ">tiramisu::function</a>).  <a href="#a4b176d9eafdba8c8d9aecbb39b9b8654">More...</a><br /></td></tr>
<tr class="separator:a4b176d9eafdba8c8d9aecbb39b9b8654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c65ca8d0b7e7f814e8af97034845e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a70c65ca8d0b7e7f814e8af97034845e8">dump_dep_graph</a> ()</td></tr>
<tr class="memdesc:a70c65ca8d0b7e7f814e8af97034845e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump the graph of dependences between computations.  <a href="#a70c65ca8d0b7e7f814e8af97034845e8">More...</a><br /></td></tr>
<tr class="separator:a70c65ca8d0b7e7f814e8af97034845e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd139be8252fd97a1c1044ca9e3337c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#afcd139be8252fd97a1c1044ca9e3337c">dump_halide_stmt</a> () const</td></tr>
<tr class="memdesc:afcd139be8252fd97a1c1044ca9e3337c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a Halide stmt that represents the function.  <a href="#afcd139be8252fd97a1c1044ca9e3337c">More...</a><br /></td></tr>
<tr class="separator:afcd139be8252fd97a1c1044ca9e3337c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a251e018163b1b860ad0a8e201326a196"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a251e018163b1b860ad0a8e201326a196">dump_iteration_domain</a> () const</td></tr>
<tr class="memdesc:a251e018163b1b860ad0a8e201326a196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump the iteration domain of the function.  <a href="#a251e018163b1b860ad0a8e201326a196">More...</a><br /></td></tr>
<tr class="separator:a251e018163b1b860ad0a8e201326a196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3c5ec997d7e9fbb659de70957275b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#adc3c5ec997d7e9fbb659de70957275b9">dump_schedule</a> () const</td></tr>
<tr class="memdesc:adc3c5ec997d7e9fbb659de70957275b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump the schedules of the computations of the function.  <a href="#adc3c5ec997d7e9fbb659de70957275b9">More...</a><br /></td></tr>
<tr class="separator:adc3c5ec997d7e9fbb659de70957275b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba881339599024ba4424f5e96496e13b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#aba881339599024ba4424f5e96496e13b">dump_sched_graph</a> ()</td></tr>
<tr class="memdesc:aba881339599024ba4424f5e96496e13b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps the graph of scheduling relations set by the higher level scheduling functions (e.g.  <a href="#aba881339599024ba4424f5e96496e13b">More...</a><br /></td></tr>
<tr class="separator:aba881339599024ba4424f5e96496e13b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c6413c361b7a2531da20971fa2d1db3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a7c6413c361b7a2531da20971fa2d1db3">dump_time_processor_domain</a> () const</td></tr>
<tr class="memdesc:a7c6413c361b7a2531da20971fa2d1db3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump (on stdout) the time processor domain of the function.  <a href="#a7c6413c361b7a2531da20971fa2d1db3">More...</a><br /></td></tr>
<tr class="separator:a7c6413c361b7a2531da20971fa2d1db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a117339bcaf69eff6664673cd8e4ce949"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a117339bcaf69eff6664673cd8e4ce949">dump_trimmed_time_processor_domain</a> () const</td></tr>
<tr class="memdesc:a117339bcaf69eff6664673cd8e4ce949"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump (on stdout) the trimmed time processor domain of the function.  <a href="#a117339bcaf69eff6664673cd8e4ce949">More...</a><br /></td></tr>
<tr class="separator:a117339bcaf69eff6664673cd8e4ce949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad42fa6e5739316d1d1fc70e4204a4b43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#ad42fa6e5739316d1d1fc70e4204a4b43">gen_c_code</a> () const</td></tr>
<tr class="memdesc:ad42fa6e5739316d1d1fc70e4204a4b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate C code and print it on stdout.  <a href="#ad42fa6e5739316d1d1fc70e4204a4b43">More...</a><br /></td></tr>
<tr class="separator:ad42fa6e5739316d1d1fc70e4204a4b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb88326a8e85eeee8cdf5cb4d9d0b859"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#aeb88326a8e85eeee8cdf5cb4d9d0b859">gen_halide_obj</a> (const std::string &amp;obj_file_name, Halide::Target::OS os, Halide::Target::Arch arch, int bits) const</td></tr>
<tr class="memdesc:aeb88326a8e85eeee8cdf5cb4d9d0b859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate an object file that contains the compiled function.  <a href="#aeb88326a8e85eeee8cdf5cb4d9d0b859">More...</a><br /></td></tr>
<tr class="separator:aeb88326a8e85eeee8cdf5cb4d9d0b859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e12737acba9e2f43a77264bca242871"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a6e12737acba9e2f43a77264bca242871">gen_halide_obj</a> (const std::string &amp;obj_file_name) const</td></tr>
<tr class="memdesc:a6e12737acba9e2f43a77264bca242871"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a6e12737acba9e2f43a77264bca242871">More...</a><br /></td></tr>
<tr class="separator:a6e12737acba9e2f43a77264bca242871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd658a57a2a7fce5955ca86405230b89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#abd658a57a2a7fce5955ca86405230b89">gen_halide_stmt</a> ()</td></tr>
<tr class="memdesc:abd658a57a2a7fce5955ca86405230b89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a Halide stmt that represents the function.  <a href="#abd658a57a2a7fce5955ca86405230b89">More...</a><br /></td></tr>
<tr class="separator:abd658a57a2a7fce5955ca86405230b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5792d0b53936a1ab74d2615810adbd4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#ab5792d0b53936a1ab74d2615810adbd4">gen_isl_ast</a> ()</td></tr>
<tr class="memdesc:ab5792d0b53936a1ab74d2615810adbd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate an isl AST that represents the function.  <a href="#ab5792d0b53936a1ab74d2615810adbd4">More...</a><br /></td></tr>
<tr class="separator:ab5792d0b53936a1ab74d2615810adbd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50be3da8d911d89f7bab886a5ac98976"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a50be3da8d911d89f7bab886a5ac98976">gen_time_space_domain</a> ()</td></tr>
<tr class="memdesc:a50be3da8d911d89f7bab886a5ac98976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the time-space domain of the function.  <a href="#a50be3da8d911d89f7bab886a5ac98976">More...</a><br /></td></tr>
<tr class="separator:a50be3da8d911d89f7bab886a5ac98976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee92effdb7c92797d2bf8f205aff10c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#aee92effdb7c92797d2bf8f205aff10c6">set_arguments</a> (const std::vector&lt; <a class="el" href="classtiramisu_1_1buffer.html">tiramisu::buffer</a> *&gt; &amp;buffer_vec)</td></tr>
<tr class="memdesc:aee92effdb7c92797d2bf8f205aff10c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the arguments of the function.  <a href="#aee92effdb7c92797d2bf8f205aff10c6">More...</a><br /></td></tr>
<tr class="separator:aee92effdb7c92797d2bf8f205aff10c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f58920ccc2ae149c678e452693a2d9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a1f58920ccc2ae149c678e452693a2d9c">set_context_set</a> (const std::string &amp;context)</td></tr>
<tr class="memdesc:a1f58920ccc2ae149c678e452693a2d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the context of the function.  <a href="#a1f58920ccc2ae149c678e452693a2d9c">More...</a><br /></td></tr>
<tr class="separator:a1f58920ccc2ae149c678e452693a2d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07666f6b68d13ebe0a436c397908e02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#ab07666f6b68d13ebe0a436c397908e02">set_context_set</a> (isl_set *context)</td></tr>
<tr class="memdesc:ab07666f6b68d13ebe0a436c397908e02"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.This function takes an ISL set as input.  <a href="#ab07666f6b68d13ebe0a436c397908e02">More...</a><br /></td></tr>
<tr class="separator:ab07666f6b68d13ebe0a436c397908e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a223e03dc3c572a4619be27c048e1aa05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a223e03dc3c572a4619be27c048e1aa05">add_buffer</a> (std::pair&lt; std::string, <a class="el" href="classtiramisu_1_1buffer.html">tiramisu::buffer</a> *&gt; buf)</td></tr>
<tr class="memdesc:a223e03dc3c572a4619be27c048e1aa05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a buffer to the function.  <a href="#a223e03dc3c572a4619be27c048e1aa05">More...</a><br /></td></tr>
<tr class="separator:a223e03dc3c572a4619be27c048e1aa05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14af8c1e4fbb05b4f0e1d1d521ad8ab1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a14af8c1e4fbb05b4f0e1d1d521ad8ab1">add_computation</a> (<a class="el" href="classtiramisu_1_1computation.html">computation</a> *cpt)</td></tr>
<tr class="memdesc:a14af8c1e4fbb05b4f0e1d1d521ad8ab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a computation to the function.  <a href="#a14af8c1e4fbb05b4f0e1d1d521ad8ab1">More...</a><br /></td></tr>
<tr class="separator:a14af8c1e4fbb05b4f0e1d1d521ad8ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4011e84bbce53bf12f3d27d268f3ec6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#ab4011e84bbce53bf12f3d27d268f3ec6">add_gpu_block_dimensions</a> (std::string stmt_name, int dim0, int dim1=-1, int dim2=-1)</td></tr>
<tr class="memdesc:ab4011e84bbce53bf12f3d27d268f3ec6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag the dimensions <code>dim0</code>, <code>dim1</code> and <code>dim2</code> of the computation <code>computation_name</code> to be mapped to GPU blocks.  <a href="#ab4011e84bbce53bf12f3d27d268f3ec6">More...</a><br /></td></tr>
<tr class="separator:ab4011e84bbce53bf12f3d27d268f3ec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a172616662673576c9e6a2338e79e2405"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a172616662673576c9e6a2338e79e2405">add_gpu_thread_dimensions</a> (std::string stmt_name, int dim0, int dim1=-1, int dim2=-1)</td></tr>
<tr class="memdesc:a172616662673576c9e6a2338e79e2405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag the dimensions <code>dim0</code>, <code>dim1</code> and <code>dim2</code> of the computation <code>computation_name</code> to be mapped to GPU threads.  <a href="#a172616662673576c9e6a2338e79e2405">More...</a><br /></td></tr>
<tr class="separator:a172616662673576c9e6a2338e79e2405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab23c049224f7978085814d78192072fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#ab23c049224f7978085814d78192072fb">add_invariant</a> (<a class="el" href="classtiramisu_1_1constant.html">tiramisu::constant</a> param)</td></tr>
<tr class="memdesc:ab23c049224f7978085814d78192072fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an invariant to the function.  <a href="#ab23c049224f7978085814d78192072fb">More...</a><br /></td></tr>
<tr class="separator:ab23c049224f7978085814d78192072fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a606a6a8f4743b80e88624335c7d6aa80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a606a6a8f4743b80e88624335c7d6aa80">add_iterator_name</a> (const std::string &amp;it_name)</td></tr>
<tr class="memdesc:a606a6a8f4743b80e88624335c7d6aa80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an iterator to the function.  <a href="#a606a6a8f4743b80e88624335c7d6aa80">More...</a><br /></td></tr>
<tr class="separator:a606a6a8f4743b80e88624335c7d6aa80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad853d05e691fa26254177c09d5157d10"><td class="memItemLeft" align="right" valign="top">isl_union_map *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#ad853d05e691fa26254177c09d5157d10">compute_dep_graph</a> ()</td></tr>
<tr class="memdesc:ad853d05e691fa26254177c09d5157d10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the graph of dependences between the computations of the function.  <a href="#ad853d05e691fa26254177c09d5157d10">More...</a><br /></td></tr>
<tr class="separator:ad853d05e691fa26254177c09d5157d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add625f08137825618695060a1a65b355"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classtiramisu_1_1buffer.html">tiramisu::buffer</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#add625f08137825618695060a1a65b355">get_arguments</a> () const</td></tr>
<tr class="memdesc:add625f08137825618695060a1a65b355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the arguments of the function.  <a href="#add625f08137825618695060a1a65b355">More...</a><br /></td></tr>
<tr class="separator:add625f08137825618695060a1a65b355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a377579b25b331c8c173634138aac881f"><td class="memItemLeft" align="right" valign="top">const std::map&lt; std::string, <a class="el" href="classtiramisu_1_1buffer.html">tiramisu::buffer</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a377579b25b331c8c173634138aac881f">get_buffers</a> () const</td></tr>
<tr class="memdesc:a377579b25b331c8c173634138aac881f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a map that represents the buffers of the function.  <a href="#a377579b25b331c8c173634138aac881f">More...</a><br /></td></tr>
<tr class="separator:a377579b25b331c8c173634138aac881f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a087765c9beb03ad8f8e7aa4f76bb43"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classtiramisu_1_1computation.html">computation</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a5a087765c9beb03ad8f8e7aa4f76bb43">get_computations</a> () const</td></tr>
<tr class="memdesc:a5a087765c9beb03ad8f8e7aa4f76bb43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector of the computations of the function.  <a href="#a5a087765c9beb03ad8f8e7aa4f76bb43">More...</a><br /></td></tr>
<tr class="separator:a5a087765c9beb03ad8f8e7aa4f76bb43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0abad59474c9f93618e80a6213a1dbbb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classtiramisu_1_1computation.html">computation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a0abad59474c9f93618e80a6213a1dbbb">get_computation_by_name</a> (std::string str) const</td></tr>
<tr class="memdesc:a0abad59474c9f93618e80a6213a1dbbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the computation of the function that has the name <code>str</code>.  <a href="#a0abad59474c9f93618e80a6213a1dbbb">More...</a><br /></td></tr>
<tr class="separator:a0abad59474c9f93618e80a6213a1dbbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a0ca6e4ee10c1ae3733f4e500e4d38"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a88a0ca6e4ee10c1ae3733f4e500e4d38">get_gpu_block_iterator</a> (const std::string &amp;comp, int lev0) const</td></tr>
<tr class="memdesc:a88a0ca6e4ee10c1ae3733f4e500e4d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a string representing the name of the GPU block iterator at dimension <code>lev0</code>.  <a href="#a88a0ca6e4ee10c1ae3733f4e500e4d38">More...</a><br /></td></tr>
<tr class="separator:a88a0ca6e4ee10c1ae3733f4e500e4d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ecd87b57b8bd3b02276e8bfd20c9d9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a62ecd87b57b8bd3b02276e8bfd20c9d9">get_gpu_thread_iterator</a> (const std::string &amp;comp, int lev0) const</td></tr>
<tr class="memdesc:a62ecd87b57b8bd3b02276e8bfd20c9d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a string representing the name of the GPU thread iterator at dimension <code>lev0</code>.  <a href="#a62ecd87b57b8bd3b02276e8bfd20c9d9">More...</a><br /></td></tr>
<tr class="separator:a62ecd87b57b8bd3b02276e8bfd20c9d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657d7178bc10f1b4166068415522ed87"><td class="memItemLeft" align="right" valign="top">isl_ctx *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a657d7178bc10f1b4166068415522ed87">get_isl_ctx</a> () const</td></tr>
<tr class="memdesc:a657d7178bc10f1b4166068415522ed87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the isl_ctx associated with this function.  <a href="#a657d7178bc10f1b4166068415522ed87">More...</a><br /></td></tr>
<tr class="separator:a657d7178bc10f1b4166068415522ed87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63cdc2a265339448b0add8f734dece2b"><td class="memItemLeft" align="right" valign="top">Halide::Internal::Stmt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a63cdc2a265339448b0add8f734dece2b">get_halide_stmt</a> () const</td></tr>
<tr class="memdesc:a63cdc2a265339448b0add8f734dece2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Halide statement that represents the whole function.  <a href="#a63cdc2a265339448b0add8f734dece2b">More...</a><br /></td></tr>
<tr class="separator:a63cdc2a265339448b0add8f734dece2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad13f1770a23bbb0869762882baf0e8c0"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classtiramisu_1_1constant.html">tiramisu::constant</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#ad13f1770a23bbb0869762882baf0e8c0">get_invariants</a> () const</td></tr>
<tr class="memdesc:ad13f1770a23bbb0869762882baf0e8c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector representing the invariants of the function (symbolic constants or variables that are invariant to the function i.e.  <a href="#ad13f1770a23bbb0869762882baf0e8c0">More...</a><br /></td></tr>
<tr class="separator:ad13f1770a23bbb0869762882baf0e8c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a813e980f7681874902ae8f8962fb1566"><td class="memItemLeft" align="right" valign="top">isl_ast_node *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a813e980f7681874902ae8f8962fb1566">get_isl_ast</a> () const</td></tr>
<tr class="memdesc:a813e980f7681874902ae8f8962fb1566"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an ISL AST that represents this function.  <a href="#a813e980f7681874902ae8f8962fb1566">More...</a><br /></td></tr>
<tr class="separator:a813e980f7681874902ae8f8962fb1566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c0b178e5a60617d84d6d1ad42c53d42"><td class="memItemLeft" align="right" valign="top">isl_union_set *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a7c0b178e5a60617d84d6d1ad42c53d42">get_iteration_domain</a> () const</td></tr>
<tr class="memdesc:a7c0b178e5a60617d84d6d1ad42c53d42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the union of all the iteration domains of the computations of the function.  <a href="#a7c0b178e5a60617d84d6d1ad42c53d42">More...</a><br /></td></tr>
<tr class="separator:a7c0b178e5a60617d84d6d1ad42c53d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a875e45aa15f4a7d6fa6929cb0c6bd657"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a875e45aa15f4a7d6fa6929cb0c6bd657">get_iterator_names</a> () const</td></tr>
<tr class="memdesc:a875e45aa15f4a7d6fa6929cb0c6bd657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the iterator names of the function.  <a href="#a875e45aa15f4a7d6fa6929cb0c6bd657">More...</a><br /></td></tr>
<tr class="separator:a875e45aa15f4a7d6fa6929cb0c6bd657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7fdc8a54f10f0165394d62e0fe32dc2"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#ab7fdc8a54f10f0165394d62e0fe32dc2">get_name</a> () const</td></tr>
<tr class="memdesc:ab7fdc8a54f10f0165394d62e0fe32dc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the function.  <a href="#ab7fdc8a54f10f0165394d62e0fe32dc2">More...</a><br /></td></tr>
<tr class="separator:ab7fdc8a54f10f0165394d62e0fe32dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b8ce22a937a534db27a55d1ddc3b343"><td class="memItemLeft" align="right" valign="top">isl_set *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a4b8ce22a937a534db27a55d1ddc3b343">get_program_context</a> () const</td></tr>
<tr class="memdesc:a4b8ce22a937a534db27a55d1ddc3b343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a set that represents the parameters of the function (an ISL set that represents the parameters and constraints over the parameters of the functions, a parameter is an invariant of the function).  <a href="#a4b8ce22a937a534db27a55d1ddc3b343">More...</a><br /></td></tr>
<tr class="separator:a4b8ce22a937a534db27a55d1ddc3b343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb810c3b2533ce46a557e83084968f6"><td class="memItemLeft" align="right" valign="top">isl_union_map *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a1fb810c3b2533ce46a557e83084968f6">get_schedule</a> () const</td></tr>
<tr class="memdesc:a1fb810c3b2533ce46a557e83084968f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the union of all the schedules of the computations of the function.  <a href="#a1fb810c3b2533ce46a557e83084968f6">More...</a><br /></td></tr>
<tr class="separator:a1fb810c3b2533ce46a557e83084968f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d316884dfd73dfa08fc29c62b41dc7"><td class="memItemLeft" align="right" valign="top">isl_union_map *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a73d316884dfd73dfa08fc29c62b41dc7">get_trimmed_schedule</a> () const</td></tr>
<tr class="memdesc:a73d316884dfd73dfa08fc29c62b41dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the union of all the trimmed schedules of the function.  <a href="#a73d316884dfd73dfa08fc29c62b41dc7">More...</a><br /></td></tr>
<tr class="separator:a73d316884dfd73dfa08fc29c62b41dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51dd88cf872a48ff56ddcf47bac2b40e"><td class="memItemLeft" align="right" valign="top">isl_union_set *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a51dd88cf872a48ff56ddcf47bac2b40e">get_time_processor_domain</a> () const</td></tr>
<tr class="memdesc:a51dd88cf872a48ff56ddcf47bac2b40e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the union of time-processor domains of each computation in the function.  <a href="#a51dd88cf872a48ff56ddcf47bac2b40e">More...</a><br /></td></tr>
<tr class="separator:a51dd88cf872a48ff56ddcf47bac2b40e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88e38c9b71cbc490051a4211ad90a034"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a88e38c9b71cbc490051a4211ad90a034">get_vector_length</a> (const std::string &amp;comp, int lev) const</td></tr>
<tr class="memdesc:a88e38c9b71cbc490051a4211ad90a034"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the computation <code>comp</code> is vectorized, return its vector length at the loop level <code>lev</code>.  <a href="#a88e38c9b71cbc490051a4211ad90a034">More...</a><br /></td></tr>
<tr class="separator:a88e38c9b71cbc490051a4211ad90a034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00c5c93c40c6ba0d8779a6c623b3db4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#af00c5c93c40c6ba0d8779a6c623b3db4">is_sched_graph_tree</a> ()</td></tr>
<tr class="memdesc:af00c5c93c40c6ba0d8779a6c623b3db4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the usage of high level scheduling comments is valid; i.e.  <a href="#af00c5c93c40c6ba0d8779a6c623b3db4">More...</a><br /></td></tr>
<tr class="separator:af00c5c93c40c6ba0d8779a6c623b3db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab62a0194f9dbc0d549fa8074fa920411"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#ab62a0194f9dbc0d549fa8074fa920411">gen_ordering_schedules</a> ()</td></tr>
<tr class="memdesc:ab62a0194f9dbc0d549fa8074fa920411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the schedules of the computations of this function to reflect the order specified using the high level scheduling commands.  <a href="#ab62a0194f9dbc0d549fa8074fa920411">More...</a><br /></td></tr>
<tr class="separator:ab62a0194f9dbc0d549fa8074fa920411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e91d4e3ffd5bf6127156ab45fc32e88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a4e91d4e3ffd5bf6127156ab45fc32e88">set_iterator_names</a> (const std::vector&lt; std::string &gt; &amp;it_names)</td></tr>
<tr class="memdesc:a4e91d4e3ffd5bf6127156ab45fc32e88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the iterator names of the function.  <a href="#a4e91d4e3ffd5bf6127156ab45fc32e88">More...</a><br /></td></tr>
<tr class="separator:a4e91d4e3ffd5bf6127156ab45fc32e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e6583e632fafb1be8ed7d256c7199f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a06e6583e632fafb1be8ed7d256c7199f">should_map_to_gpu_block</a> (const std::string &amp;comp, int lev0) const</td></tr>
<tr class="memdesc:a06e6583e632fafb1be8ed7d256c7199f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the computation <code>comp</code> should be mapped to GPU block at the loop levels <code>lev0</code>.  <a href="#a06e6583e632fafb1be8ed7d256c7199f">More...</a><br /></td></tr>
<tr class="separator:a06e6583e632fafb1be8ed7d256c7199f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae73e5bad35ab9d01f4364e57185f1ca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#aae73e5bad35ab9d01f4364e57185f1ca">should_map_to_gpu_thread</a> (const std::string &amp;comp, int lev0) const</td></tr>
<tr class="memdesc:aae73e5bad35ab9d01f4364e57185f1ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the computation <code>comp</code> should be mapped to GPU thread at the loop levels <code>lev0</code>.  <a href="#aae73e5bad35ab9d01f4364e57185f1ca">More...</a><br /></td></tr>
<tr class="separator:aae73e5bad35ab9d01f4364e57185f1ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76566d76740511bffac3f145e7d2323f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a76566d76740511bffac3f145e7d2323f">should_parallelize</a> (const std::string &amp;comp, int lev) const</td></tr>
<tr class="memdesc:a76566d76740511bffac3f145e7d2323f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the computation <code>comp</code> should be parallelized at the loop level <code>lev</code>.  <a href="#a76566d76740511bffac3f145e7d2323f">More...</a><br /></td></tr>
<tr class="separator:a76566d76740511bffac3f145e7d2323f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af43b64d12ca7fbda31ede67017cd428c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#af43b64d12ca7fbda31ede67017cd428c">should_unroll</a> (const std::string &amp;comp, int lev) const</td></tr>
<tr class="memdesc:af43b64d12ca7fbda31ede67017cd428c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the computation <code>comp</code> should be unrolled at the loop level <code>lev</code>.  <a href="#af43b64d12ca7fbda31ede67017cd428c">More...</a><br /></td></tr>
<tr class="separator:af43b64d12ca7fbda31ede67017cd428c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f1f5d3d2c00a99078fa7948d95c3e3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#ab2f1f5d3d2c00a99078fa7948d95c3e3">should_vectorize</a> (const std::string &amp;comp, int lev) const</td></tr>
<tr class="memdesc:ab2f1f5d3d2c00a99078fa7948d95c3e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the computation <code>comp</code> should be vectorized at the loop level <code>lev</code>.  <a href="#ab2f1f5d3d2c00a99078fa7948d95c3e3">More...</a><br /></td></tr>
<tr class="separator:ab2f1f5d3d2c00a99078fa7948d95c3e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a8ec5724b5bbb47dcfa8571f855d20bbe"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classtiramisu_1_1computation.html">tiramisu::computation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a8ec5724b5bbb47dcfa8571f855d20bbe">automatically_allocated</a></td></tr>
<tr class="memdesc:a8ec5724b5bbb47dcfa8571f855d20bbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keeps track of allocation computations created using allocate_and_map_buffer_automatically() to schedule them during gen_ordering_schedules.  <a href="#a8ec5724b5bbb47dcfa8571f855d20bbe">More...</a><br /></td></tr>
<tr class="separator:a8ec5724b5bbb47dcfa8571f855d20bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865002ee46e628ee370bdbfa2be9e0d7"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; <a class="el" href="classtiramisu_1_1computation.html">tiramisu::computation</a> *, std::unordered_map&lt; <a class="el" href="classtiramisu_1_1computation.html">tiramisu::computation</a> *, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a865002ee46e628ee370bdbfa2be9e0d7">sched_graph</a></td></tr>
<tr class="memdesc:a865002ee46e628ee370bdbfa2be9e0d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores all high level scheduling instructions between computations; i.e.  <a href="#a865002ee46e628ee370bdbfa2be9e0d7">More...</a><br /></td></tr>
<tr class="separator:a865002ee46e628ee370bdbfa2be9e0d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb348adb9016451a8eeb799705455edd"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; <a class="el" href="classtiramisu_1_1computation.html">tiramisu::computation</a> *, std::unordered_map&lt; <a class="el" href="classtiramisu_1_1computation.html">tiramisu::computation</a> *, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#aeb348adb9016451a8eeb799705455edd">sched_graph_reversed</a></td></tr>
<tr class="memdesc:aeb348adb9016451a8eeb799705455edd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as sched_graph, except in reverse order (from after to before).  <a href="#aeb348adb9016451a8eeb799705455edd">More...</a><br /></td></tr>
<tr class="separator:aeb348adb9016451a8eeb799705455edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a587856ea73f0f552cc711091a3b8ced8"><td class="memItemLeft" align="right" valign="top">std::unordered_set&lt; <a class="el" href="classtiramisu_1_1computation.html">tiramisu::computation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a587856ea73f0f552cc711091a3b8ced8">starting_computations</a></td></tr>
<tr class="memdesc:a587856ea73f0f552cc711091a3b8ced8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of all computations that have no computation scheduled before them.  <a href="#a587856ea73f0f552cc711091a3b8ced8">More...</a><br /></td></tr>
<tr class="separator:a587856ea73f0f552cc711091a3b8ced8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67c71ad05ac2b8c0312dc5ab667e0cf4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1function.html#a67c71ad05ac2b8c0312dc5ab667e0cf4">use_low_level_scheduling_commands</a></td></tr>
<tr class="memdesc:a67c71ad05ac2b8c0312dc5ab667e0cf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A boolean set to true if low level scheduling was used in the program.  <a href="#a67c71ad05ac2b8c0312dc5ab667e0cf4">More...</a><br /></td></tr>
<tr class="separator:a67c71ad05ac2b8c0312dc5ab667e0cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class to represent functions in Tiramisu. </p>
<p>A function in Tiramisu is composed of a set of computations (<a class="el" href="classtiramisu_1_1computation.html" title="A class that represents computations. ">tiramisu::computation</a>). </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorials_2tutorial_06_8cpp-example.html#_a3">tutorials/tutorial_06.cpp</a>.</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="core_8h_source.html#l00059">59</a> of file <a class="el" href="core_8h_source.html">core.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a41227e14c97d5e18d85797ea9000a646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41227e14c97d5e18d85797ea9000a646">&#9670;&nbsp;</a></span>function()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tiramisu::function::function </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a function called <code>name</code>. </p>
<p>Function names should not start with _ (an underscore). Names starting with _ are reserved names. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a223e03dc3c572a4619be27c048e1aa05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a223e03dc3c572a4619be27c048e1aa05">&#9670;&nbsp;</a></span>add_buffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::add_buffer </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; std::string, <a class="el" href="classtiramisu_1_1buffer.html">tiramisu::buffer</a> *&gt;&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a buffer to the function. </p>
<p>The buffers of the function are either:</p><ul>
<li>buffers passed to the function as arguments, or</li>
<li>buffers that are declared and allocated within the function itself. The first element of the pair is the name of the buffer (it is used as a key), the second element of the pair is a pointer to the buffer. </li>
</ul>

</div>
</div>
<a id="a14af8c1e4fbb05b4f0e1d1d521ad8ab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14af8c1e4fbb05b4f0e1d1d521ad8ab1">&#9670;&nbsp;</a></span>add_computation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::add_computation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1computation.html">computation</a> *&#160;</td>
          <td class="paramname"><em>cpt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a computation to the function. </p>
<p>The order in which computations are added to the function is not important. The order of execution is specified using the schedule. This doesn't allow computations with duplicate names. </p>

</div>
</div>
<a id="a92b1a049a512671258cf346af4b59ec6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92b1a049a512671258cf346af4b59ec6">&#9670;&nbsp;</a></span>add_context_constraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::add_context_constraints </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>new_context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a set of constraints to the context of the program. </p>
<p>This command is useful for providing constraints over the constants used within a tiramisu function. This call intersects the set <code>new_context</code> (input) with the context of the function.</p>
<p>The context of a function is an ISL set that represents constraints over the parameters of the functions. A parameter of a function is a constant used in that function.</p>
<p>An example of a context set is the following: "[N,M]-&gt;{: M&gt;0 and N&gt;0}" This context set indicates that the two parameters N and M are strictly positive.</p>
<p><code>new_context</code> should have the same space as the context set. </p>

</div>
</div>
<a id="ab4011e84bbce53bf12f3d27d268f3ec6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4011e84bbce53bf12f3d27d268f3ec6">&#9670;&nbsp;</a></span>add_gpu_block_dimensions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::add_gpu_block_dimensions </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>stmt_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim1</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim2</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tag the dimensions <code>dim0</code>, <code>dim1</code> and <code>dim2</code> of the computation <code>computation_name</code> to be mapped to GPU blocks. </p>
<p>The dimension 0 represents the outermost loop level (it corresponds to the leftmost dimension in the iteration space).</p>
<p>If the user does not want to tag <code>dim1</code> or <code>dim2</code>, he can leave their values to default value (i.e., -1). They will not be tagged.</p>
<p>For example</p>
<p>add_gpu_block_dimensions("S0", 1, 2);</p>
<p>Will tag the dimensions 1 and 2 to be transformed to GPU blocks. </p>

</div>
</div>
<a id="a172616662673576c9e6a2338e79e2405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a172616662673576c9e6a2338e79e2405">&#9670;&nbsp;</a></span>add_gpu_thread_dimensions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::add_gpu_thread_dimensions </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>stmt_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim1</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim2</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tag the dimensions <code>dim0</code>, <code>dim1</code> and <code>dim2</code> of the computation <code>computation_name</code> to be mapped to GPU threads. </p>
<p>The dimension 0 represents the outermost loop level (it corresponds to the leftmost dimension in the iteration space).</p>
<p>If the user does not want to tag <code>dim1</code> or <code>dim2</code>, he can leave their values to default value (i.e., -1). They will not be tagged.</p>
<p>For example</p>
<p>add_gpu_block_dimensions("S0", 1, -1, -1);</p>
<p>Will tag the dimension 1 to be transformed to GPU threads. </p>

</div>
</div>
<a id="ab23c049224f7978085814d78192072fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab23c049224f7978085814d78192072fb">&#9670;&nbsp;</a></span>add_invariant()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::add_invariant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1constant.html">tiramisu::constant</a>&#160;</td>
          <td class="paramname"><em>param</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an invariant to the function. </p>

</div>
</div>
<a id="a606a6a8f4743b80e88624335c7d6aa80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a606a6a8f4743b80e88624335c7d6aa80">&#9670;&nbsp;</a></span>add_iterator_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::add_iterator_name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>it_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an iterator to the function. </p>

</div>
</div>
<a id="af3e42f31722b17263102734867aaaa71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3e42f31722b17263102734867aaaa71">&#9670;&nbsp;</a></span>allocate_and_map_buffers_automatically()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::allocate_and_map_buffers_automatically </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For each computation, allocate a buffer and map the computation to that buffer. </p>
<p>For each computation in the function:</p><ul>
<li>Allocate a buffer where the size of the buffer is derived automatically. Assuming the name of the computation is C, the name of the generated buffer is _C_buffer.</li>
<li>Map the computation to the allocated buffer (one-to-one mapping). For more details about one-to-one mapping, see <a class="el" href="classtiramisu_1_1computation.html#a5b9d5764ae39e427bf252ba0ea736031" title="Bind this computation to a buffer. ">computation::bind_to</a>. </li>
</ul>

</div>
</div>
<a id="af5662551a604ffea619b3bbe385120d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5662551a604ffea619b3bbe385120d8">&#9670;&nbsp;</a></span>compute_bounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::compute_bounds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the bounds of each computation. </p>
<p>Computing the bounds of each computation means computing the constraints over the iteration domains of each computation in the function.</p>
<p>In order to deduce bounds, Tiramisu first identifies the final consumers in the function (i.e., computations that do not have any consumer). Then, it propagates the bounds over the final consumers to their producers. The bounds of each consumer are used to deduce the bounds over its producer.</p>
<p>To take benefit of bound inference, the user can declare computations without providing constraints on their iteration domains. For example the user can declare the following computations (the left side is the iteration domain, while the right side is the expression attached to each computation)</p>
<div class="fragment"><div class="line">{A[i]        } : 0</div><div class="line">{B[i]        } : 0</div><div class="line">{C[i]        } : A[i] + B[i]</div><div class="line">{D[i]: 0&lt;=i&lt;N} : 2*C[i]</div></div><!-- fragment --><p>The user needs only to provide constraints over the domains of the last computations (last consumers), and Tiramisu will propagate these constraints to all the chain of computations that produce for those consumers. In the previous example, constraints over the iteration domain were only provided for the last consumer "D[i]" and no constraints were provided for the other computations. Bound inference would deduce the constraints for the computations A[i], B[i] and C[i].</p>
<p>Note that bound inference is not possible if you have multiple definitions of the same computation. For example, if you have multiple definitions of the same computations, in such a case the user should provide constraints of the iteration domain of the computation. Example:</p>
<div class="fragment"><div class="line">{A[i]        } : 0</div><div class="line">{C[i]: i=0   } : 0</div><div class="line">{C[i]: 1&lt;=i&lt;N} : C[i-1] + A[i]</div><div class="line">{D[i]: 0&lt;=i&lt;N} : 2*C[i]</div></div><!-- fragment --><p>In this case, constraints over the computations defining C[i] should be provided. </p>

</div>
</div>
<a id="ad853d05e691fa26254177c09d5157d10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad853d05e691fa26254177c09d5157d10">&#9670;&nbsp;</a></span>compute_dep_graph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">isl_union_map* tiramisu::function::compute_dep_graph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the graph of dependences between the computations of the function. </p>
<p>Example</p>
<p>C[0] = 0 D[1] = C[0] D[2] = C[0] {C[0] -&gt; D[1]; C[0]-&gt;D[2]} </p>

</div>
</div>
<a id="a4b176d9eafdba8c8d9aecbb39b9b8654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b176d9eafdba8c8d9aecbb39b9b8654">&#9670;&nbsp;</a></span>dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::dump </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exhaustive</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump the function on standard output (dump most of the fields of <a class="el" href="classtiramisu_1_1function.html" title="A class to represent functions in Tiramisu. ">tiramisu::function</a>). </p>
<p>This is mainly useful for debugging. If <code>exhaustive</code> is set to true, all the fields of the function class are printed. </p>

</div>
</div>
<a id="a70c65ca8d0b7e7f814e8af97034845e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70c65ca8d0b7e7f814e8af97034845e8">&#9670;&nbsp;</a></span>dump_dep_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::dump_dep_graph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump the graph of dependences between computations. </p>
<p>The graph of dependences is a union of maps (relations) from producers to consumers. </p>

</div>
</div>
<a id="afcd139be8252fd97a1c1044ca9e3337c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcd139be8252fd97a1c1044ca9e3337c">&#9670;&nbsp;</a></span>dump_halide_stmt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::dump_halide_stmt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a Halide stmt that represents the function. </p>
<p><a class="el" href="classtiramisu_1_1function.html#abd658a57a2a7fce5955ca86405230b89" title="Generate a Halide stmt that represents the function. ">tiramisu::function::gen_halide_stmt</a> should be called before calling this function. </p>

</div>
</div>
<a id="a251e018163b1b860ad0a8e201326a196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a251e018163b1b860ad0a8e201326a196">&#9670;&nbsp;</a></span>dump_iteration_domain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::dump_iteration_domain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump the iteration domain of the function. </p>
<p>This is mainly useful for debugging. </p>

</div>
</div>
<a id="aba881339599024ba4424f5e96496e13b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba881339599024ba4424f5e96496e13b">&#9670;&nbsp;</a></span>dump_sched_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::dump_sched_graph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dumps the graph of scheduling relations set by the higher level scheduling functions (e.g. </p>
<p>after, before, compute_at...).</p>
<p>This is mainly useful for debugging. This function can be called at any point during scheduling. </p>

</div>
</div>
<a id="adc3c5ec997d7e9fbb659de70957275b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc3c5ec997d7e9fbb659de70957275b9">&#9670;&nbsp;</a></span>dump_schedule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::dump_schedule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump the schedules of the computations of the function. </p>
<p>This function is mainly useful for debugging. See tiramisu::computations::set_low_level_schedule for details about the schedule. </p>

</div>
</div>
<a id="a7c6413c361b7a2531da20971fa2d1db3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c6413c361b7a2531da20971fa2d1db3">&#9670;&nbsp;</a></span>dump_time_processor_domain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::dump_time_processor_domain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump (on stdout) the time processor domain of the function. </p>
<p>The time-processor domain should be generated using tiramisu::function::gen_time_processor_domain before calling this function. This is mainly useful for debugging. </p>

</div>
</div>
<a id="a117339bcaf69eff6664673cd8e4ce949"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a117339bcaf69eff6664673cd8e4ce949">&#9670;&nbsp;</a></span>dump_trimmed_time_processor_domain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::dump_trimmed_time_processor_domain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump (on stdout) the trimmed time processor domain of the function. </p>
<p>The time-processor domain should be generated using tiramisu::function::gen_time_processor_domain before calling this function. This is mainly useful for debugging. The difference between the time-processor domain and the trimmed time-processor domain is that the trimmed one does not have the duplicate dimension. We remove it before printing. The trimmed time-processor domain is the domain used for code generation. </p>

</div>
</div>
<a id="ad42fa6e5739316d1d1fc70e4204a4b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad42fa6e5739316d1d1fc70e4204a4b43">&#9670;&nbsp;</a></span>gen_c_code()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::gen_c_code </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate C code and print it on stdout. </p>
<p>Currently C code code generation is very basic and does not support many features compared to the Halide code generator. Use this for debugging only. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorials_2tutorial_06_8cpp-example.html#a21">tutorials/tutorial_06.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="aeb88326a8e85eeee8cdf5cb4d9d0b859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb88326a8e85eeee8cdf5cb4d9d0b859">&#9670;&nbsp;</a></span>gen_halide_obj() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::gen_halide_obj </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>obj_file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Halide::Target::OS&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Halide::Target::Arch&#160;</td>
          <td class="paramname"><em>arch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate an object file that contains the compiled function. </p>
<p>This function relies on Halide to generate the object file.</p>
<p><code>obj_file_name</code> indicates the name of the generated file.</p>
<p><code>os</code> indicates the target operating system (Halide::Target::OS).</p>
<p><code>arch</code> indicates the architecture of the target (the instruction set).</p>
<p><code>bits</code> indicate the bit-width of the target machine. must be 0 for unknown, or 32 or 64. For a full list of supported values for <code>os</code> and <code>arch</code> please check the documentation of Halide::Target (<a href="http://halide-lang.org/docs/struct_halide_1_1_target.html">http://halide-lang.org/docs/struct_halide_1_1_target.html</a>). If the machine parameters are not supplied, Halide detects the parameters of the host machine automatically. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorials_2tutorial_06_8cpp-example.html#a22">tutorials/tutorial_06.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="a6e12737acba9e2f43a77264bca242871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e12737acba9e2f43a77264bca242871">&#9670;&nbsp;</a></span>gen_halide_obj() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::gen_halide_obj </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>obj_file_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="abd658a57a2a7fce5955ca86405230b89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd658a57a2a7fce5955ca86405230b89">&#9670;&nbsp;</a></span>gen_halide_stmt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::gen_halide_stmt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a Halide stmt that represents the function. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorials_2tutorial_06_8cpp-example.html#a20">tutorials/tutorial_06.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="ab5792d0b53936a1ab74d2615810adbd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5792d0b53936a1ab74d2615810adbd4">&#9670;&nbsp;</a></span>gen_isl_ast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::gen_isl_ast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate an isl AST that represents the function. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorials_2tutorial_06_8cpp-example.html#a19">tutorials/tutorial_06.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="ab62a0194f9dbc0d549fa8074fa920411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab62a0194f9dbc0d549fa8074fa920411">&#9670;&nbsp;</a></span>gen_ordering_schedules()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::gen_ordering_schedules </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify the schedules of the computations of this function to reflect the order specified using the high level scheduling commands. </p>
<p>Commands like .after() and .before() do not directly modify the schedules but rather modify the sched_graph graph. </p>

</div>
</div>
<a id="a50be3da8d911d89f7bab886a5ac98976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50be3da8d911d89f7bab886a5ac98976">&#9670;&nbsp;</a></span>gen_time_space_domain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::gen_time_space_domain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the time-space domain of the function. </p>
<p>In this representation, the logical time of execution and the processor where the computation will be executed are both specified. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorials_2tutorial_06_8cpp-example.html#a18">tutorials/tutorial_06.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="add625f08137825618695060a1a65b355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add625f08137825618695060a1a65b355">&#9670;&nbsp;</a></span>get_arguments()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classtiramisu_1_1buffer.html">tiramisu::buffer</a> *&gt;&amp; tiramisu::function::get_arguments </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the arguments of the function. </p>

</div>
</div>
<a id="a377579b25b331c8c173634138aac881f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a377579b25b331c8c173634138aac881f">&#9670;&nbsp;</a></span>get_buffers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt;std::string, <a class="el" href="classtiramisu_1_1buffer.html">tiramisu::buffer</a> *&gt;&amp; tiramisu::function::get_buffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a map that represents the buffers of the function. </p>
<p>The buffers of the function are buffers that are either passed to the function as arguments or are buffers that are declared and allocated within the function itself. The names of the buffers are used as a key for the map. </p>

</div>
</div>
<a id="a0abad59474c9f93618e80a6213a1dbbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0abad59474c9f93618e80a6213a1dbbb">&#9670;&nbsp;</a></span>get_computation_by_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classtiramisu_1_1computation.html">computation</a> *&gt; tiramisu::function::get_computation_by_name </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the computation of the function that has the name <code>str</code>. </p>

</div>
</div>
<a id="a5a087765c9beb03ad8f8e7aa4f76bb43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a087765c9beb03ad8f8e7aa4f76bb43">&#9670;&nbsp;</a></span>get_computations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classtiramisu_1_1computation.html">computation</a> *&gt;&amp; tiramisu::function::get_computations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a vector of the computations of the function. </p>
<p>The order of the computations in the vector does not have any effect on the actual order of execution of the computations. The order of execution of computations is specified through the schedule. </p>

</div>
</div>
<a id="a88a0ca6e4ee10c1ae3733f4e500e4d38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88a0ca6e4ee10c1ae3733f4e500e4d38">&#9670;&nbsp;</a></span>get_gpu_block_iterator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string tiramisu::function::get_gpu_block_iterator </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lev0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a string representing the name of the GPU block iterator at dimension <code>lev0</code>. </p>
<p>This function only returns a non-empty string if the computation <code>comp</code> is mapped to a GPU block at the dimension <code>lev0</code>. </p>

</div>
</div>
<a id="a62ecd87b57b8bd3b02276e8bfd20c9d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62ecd87b57b8bd3b02276e8bfd20c9d9">&#9670;&nbsp;</a></span>get_gpu_thread_iterator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string tiramisu::function::get_gpu_thread_iterator </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lev0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a string representing the name of the GPU thread iterator at dimension <code>lev0</code>. </p>
<p>This function only returns a non-empty string if the computation <code>comp</code> is mapped to a GPU thread at the dimension <code>lev0</code>. </p>

</div>
</div>
<a id="a63cdc2a265339448b0add8f734dece2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63cdc2a265339448b0add8f734dece2b">&#9670;&nbsp;</a></span>get_halide_stmt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Halide::Internal::Stmt tiramisu::function::get_halide_stmt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the Halide statement that represents the whole function. </p>
<p>The Halide statement is generated by the code generator. This function should not be called before calling the code generator. </p>

</div>
</div>
<a id="ad13f1770a23bbb0869762882baf0e8c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad13f1770a23bbb0869762882baf0e8c0">&#9670;&nbsp;</a></span>get_invariants()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classtiramisu_1_1constant.html">tiramisu::constant</a>&gt;&amp; tiramisu::function::get_invariants </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a vector representing the invariants of the function (symbolic constants or variables that are invariant to the function i.e. </p>
<p>do not change their value during the execution of the function). </p>

</div>
</div>
<a id="a813e980f7681874902ae8f8962fb1566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a813e980f7681874902ae8f8962fb1566">&#9670;&nbsp;</a></span>get_isl_ast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">isl_ast_node* tiramisu::function::get_isl_ast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an ISL AST that represents this function. </p>
<p>This function itself does not generate the ISL AST, it just returns it if it already exists. The function <a class="el" href="classtiramisu_1_1function.html#ab5792d0b53936a1ab74d2615810adbd4" title="Generate an isl AST that represents the function. ">gen_isl_ast()</a> should be called before calling this function. </p>

</div>
</div>
<a id="a657d7178bc10f1b4166068415522ed87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a657d7178bc10f1b4166068415522ed87">&#9670;&nbsp;</a></span>get_isl_ctx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">isl_ctx* tiramisu::function::get_isl_ctx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the isl_ctx associated with this function. </p>
<p>This is an ISL specific object required when calling certain ISL functions. It does not represent the set of parameters of the function (which should be retrieved by calling <a class="el" href="classtiramisu_1_1function.html#a4b8ce22a937a534db27a55d1ddc3b343" title="Return a set that represents the parameters of the function (an ISL set that represents the parameter...">get_program_context()</a>). </p>

</div>
</div>
<a id="a7c0b178e5a60617d84d6d1ad42c53d42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c0b178e5a60617d84d6d1ad42c53d42">&#9670;&nbsp;</a></span>get_iteration_domain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">isl_union_set* tiramisu::function::get_iteration_domain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the union of all the iteration domains of the computations of the function. </p>

</div>
</div>
<a id="a875e45aa15f4a7d6fa6929cb0c6bd657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a875e45aa15f4a7d6fa6929cb0c6bd657">&#9670;&nbsp;</a></span>get_iterator_names()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::string&gt;&amp; tiramisu::function::get_iterator_names </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the iterator names of the function. </p>

</div>
</div>
<a id="ab7fdc8a54f10f0165394d62e0fe32dc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7fdc8a54f10f0165394d62e0fe32dc2">&#9670;&nbsp;</a></span>get_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; tiramisu::function::get_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the name of the function. </p>

</div>
</div>
<a id="a4b8ce22a937a534db27a55d1ddc3b343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b8ce22a937a534db27a55d1ddc3b343">&#9670;&nbsp;</a></span>get_program_context()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">isl_set* tiramisu::function::get_program_context </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a set that represents the parameters of the function (an ISL set that represents the parameters and constraints over the parameters of the functions, a parameter is an invariant of the function). </p>
<p>This set is also known as the context of the program. An example of a context set is the following: "[N,M]-&gt;{: M&gt;0 and N&gt;0}" This context set indicates that the two parameters N and M are strictly positive. </p>

</div>
</div>
<a id="a1fb810c3b2533ce46a557e83084968f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fb810c3b2533ce46a557e83084968f6">&#9670;&nbsp;</a></span>get_schedule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">isl_union_map* tiramisu::function::get_schedule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the union of all the schedules of the computations of the function. </p>

</div>
</div>
<a id="a51dd88cf872a48ff56ddcf47bac2b40e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51dd88cf872a48ff56ddcf47bac2b40e">&#9670;&nbsp;</a></span>get_time_processor_domain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">isl_union_set* tiramisu::function::get_time_processor_domain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the union of time-processor domains of each computation in the function. </p>
<p>In the time-processor representation, the logical time of execution and the processor where the computation will be executed are both specified. </p>

</div>
</div>
<a id="a73d316884dfd73dfa08fc29c62b41dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73d316884dfd73dfa08fc29c62b41dc7">&#9670;&nbsp;</a></span>get_trimmed_schedule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">isl_union_map* tiramisu::function::get_trimmed_schedule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the union of all the trimmed schedules of the function. </p>
<p>A trimmed schedule is the schedule without the duplication dimension (the schedule dimension used to indicate duplicate computations). </p>

</div>
</div>
<a id="a88e38c9b71cbc490051a4211ad90a034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88e38c9b71cbc490051a4211ad90a034">&#9670;&nbsp;</a></span>get_vector_length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int tiramisu::function::get_vector_length </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the computation <code>comp</code> is vectorized, return its vector length at the loop level <code>lev</code>. </p>

</div>
</div>
<a id="af00c5c93c40c6ba0d8779a6c623b3db4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af00c5c93c40c6ba0d8779a6c623b3db4">&#9670;&nbsp;</a></span>is_sched_graph_tree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tiramisu::function::is_sched_graph_tree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the usage of high level scheduling comments is valid; i.e. </p>
<p>if the scheduling relations formed using before, after, compute_at, etc.. form a tree.</p>
<p>More specifically, it verifies that:</p><ul>
<li>There should be exactly one computation with no computation scheduled before it.</li>
<li>Each other computation should have exactly one computation scheduled before it. </li>
</ul>

</div>
</div>
<a id="aee92effdb7c92797d2bf8f205aff10c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee92effdb7c92797d2bf8f205aff10c6">&#9670;&nbsp;</a></span>set_arguments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::set_arguments </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classtiramisu_1_1buffer.html">tiramisu::buffer</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer_vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the arguments of the function. </p>
<p>The arguments of the function are provided as a vector of pointers to buffers. Each buffer represents an argument to the function. During code generation, the arguments in the vector will become the arguments of the generated function (with the order of their appearance in the vector). </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorials_2tutorial_06_8cpp-example.html#a17">tutorials/tutorial_06.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="a1f58920ccc2ae149c678e452693a2d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f58920ccc2ae149c678e452693a2d9c">&#9670;&nbsp;</a></span>set_context_set() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::set_context_set </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the context of the function. </p>
<p>A context is an ISL set that represents constraints over the parameters of the functions (a parameter is an invariant variable for the function). An example of a context set is the following: "[N,M]-&gt;{: M&gt;0 and N&gt;0}" This context set indicates that the two parameters N and M are strictly positive.</p>
<p>This function takes a string that represents and ISL set. </p>

</div>
</div>
<a id="ab07666f6b68d13ebe0a436c397908e02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab07666f6b68d13ebe0a436c397908e02">&#9670;&nbsp;</a></span>set_context_set() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::set_context_set </td>
          <td>(</td>
          <td class="paramtype">isl_set *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.This function takes an ISL set as input. </p>

</div>
</div>
<a id="a4e91d4e3ffd5bf6127156ab45fc32e88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e91d4e3ffd5bf6127156ab45fc32e88">&#9670;&nbsp;</a></span>set_iterator_names()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::function::set_iterator_names </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>it_names</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the iterator names of the function. </p>
<p>This function overrides any previously set iterator names. </p>

</div>
</div>
<a id="a06e6583e632fafb1be8ed7d256c7199f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06e6583e632fafb1be8ed7d256c7199f">&#9670;&nbsp;</a></span>should_map_to_gpu_block()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tiramisu::function::should_map_to_gpu_block </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lev0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the computation <code>comp</code> should be mapped to GPU block at the loop levels <code>lev0</code>. </p>

</div>
</div>
<a id="aae73e5bad35ab9d01f4364e57185f1ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae73e5bad35ab9d01f4364e57185f1ca">&#9670;&nbsp;</a></span>should_map_to_gpu_thread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tiramisu::function::should_map_to_gpu_thread </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lev0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the computation <code>comp</code> should be mapped to GPU thread at the loop levels <code>lev0</code>. </p>

</div>
</div>
<a id="a76566d76740511bffac3f145e7d2323f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76566d76740511bffac3f145e7d2323f">&#9670;&nbsp;</a></span>should_parallelize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tiramisu::function::should_parallelize </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the computation <code>comp</code> should be parallelized at the loop level <code>lev</code>. </p>

</div>
</div>
<a id="af43b64d12ca7fbda31ede67017cd428c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af43b64d12ca7fbda31ede67017cd428c">&#9670;&nbsp;</a></span>should_unroll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tiramisu::function::should_unroll </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the computation <code>comp</code> should be unrolled at the loop level <code>lev</code>. </p>

</div>
</div>
<a id="ab2f1f5d3d2c00a99078fa7948d95c3e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2f1f5d3d2c00a99078fa7948d95c3e3">&#9670;&nbsp;</a></span>should_vectorize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tiramisu::function::should_vectorize </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the computation <code>comp</code> should be vectorized at the loop level <code>lev</code>. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a8ec5724b5bbb47dcfa8571f855d20bbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ec5724b5bbb47dcfa8571f855d20bbe">&#9670;&nbsp;</a></span>automatically_allocated</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classtiramisu_1_1computation.html">tiramisu::computation</a> *&gt; tiramisu::function::automatically_allocated</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Keeps track of allocation computations created using allocate_and_map_buffer_automatically() to schedule them during gen_ordering_schedules. </p>

<p class="definition">Definition at line <a class="el" href="core_8h_source.html#l00369">369</a> of file <a class="el" href="core_8h_source.html">core.h</a>.</p>

</div>
</div>
<a id="a865002ee46e628ee370bdbfa2be9e0d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a865002ee46e628ee370bdbfa2be9e0d7">&#9670;&nbsp;</a></span>sched_graph</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;<a class="el" href="classtiramisu_1_1computation.html">tiramisu::computation</a> *, std::unordered_map&lt;<a class="el" href="classtiramisu_1_1computation.html">tiramisu::computation</a> *, int&gt; &gt; tiramisu::function::sched_graph</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores all high level scheduling instructions between computations; i.e. </p>
<p>if a user calls for example c2.after(c1, L), sched_graph[&amp;c1] would contain the key &amp;c2, and sched_graph[&amp;c1][&amp;c2] = L. At the end of scheduling, the graph should respect the following rules:</p><ul>
<li>There should be exactly one computation with no computation scheduled before it.</li>
<li>Each other computation should have exactly one computation scheduled before it. In other words, the graph should be a valid tree. Does not include allocation computations created using allocate_and_map_buffer_automatically(). </li>
</ul>

<p class="definition">Definition at line <a class="el" href="core_8h_source.html#l00554">554</a> of file <a class="el" href="core_8h_source.html">core.h</a>.</p>

</div>
</div>
<a id="aeb348adb9016451a8eeb799705455edd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb348adb9016451a8eeb799705455edd">&#9670;&nbsp;</a></span>sched_graph_reversed</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;<a class="el" href="classtiramisu_1_1computation.html">tiramisu::computation</a> *, std::unordered_map&lt;<a class="el" href="classtiramisu_1_1computation.html">tiramisu::computation</a> *, int&gt; &gt; tiramisu::function::sched_graph_reversed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as sched_graph, except in reverse order (from after to before). </p>

<p class="definition">Definition at line <a class="el" href="core_8h_source.html#l00560">560</a> of file <a class="el" href="core_8h_source.html">core.h</a>.</p>

</div>
</div>
<a id="a587856ea73f0f552cc711091a3b8ced8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a587856ea73f0f552cc711091a3b8ced8">&#9670;&nbsp;</a></span>starting_computations</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_set&lt;<a class="el" href="classtiramisu_1_1computation.html">tiramisu::computation</a> *&gt; tiramisu::function::starting_computations</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The set of all computations that have no computation scheduled before them. </p>
<p>Does not include allocation computations created using allocate_and_map_buffer_automatically(). </p>

<p class="definition">Definition at line <a class="el" href="core_8h_source.html#l00603">603</a> of file <a class="el" href="core_8h_source.html">core.h</a>.</p>

</div>
</div>
<a id="a67c71ad05ac2b8c0312dc5ab667e0cf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67c71ad05ac2b8c0312dc5ab667e0cf4">&#9670;&nbsp;</a></span>use_low_level_scheduling_commands</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tiramisu::function::use_low_level_scheduling_commands</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A boolean set to true if low level scheduling was used in the program. </p>
<p>If it is used, then high level scheduling commands such as .before(), .after(), ... </p>

<p class="definition">Definition at line <a class="el" href="core_8h_source.html#l00610">610</a> of file <a class="el" href="core_8h_source.html">core.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="core_8h_source.html">core.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacetiramisu.html">tiramisu</a></li><li class="navelem"><a class="el" href="classtiramisu_1_1function.html">function</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
