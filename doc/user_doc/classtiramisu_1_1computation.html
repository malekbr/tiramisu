<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tiramisu Optimization Framework: tiramisu::computation Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Tiramisu Optimization Framework
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classtiramisu_1_1computation.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classtiramisu_1_1computation-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tiramisu::computation Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A class that represents computations.  
 <a href="classtiramisu_1_1computation.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="core_8h_source.html">core.h</a>&gt;</code></p>

<p>Inherited by <a class="el" href="classtiramisu_1_1constant.html">tiramisu::constant</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a802535b5fb6144e54a83051f7b612b86"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a802535b5fb6144e54a83051f7b612b86">computation</a> (std::string iteration_domain, <a class="el" href="classtiramisu_1_1expr.html">tiramisu::expr</a> e, bool schedule_this_computation, <a class="el" href="namespacetiramisu.html#adacb3196c1c6ddd14350580e70717354">tiramisu::primitive_t</a> t, <a class="el" href="classtiramisu_1_1function.html">tiramisu::function</a> *fct)</td></tr>
<tr class="memdesc:a802535b5fb6144e54a83051f7b612b86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for computations.  <a href="#a802535b5fb6144e54a83051f7b612b86">More...</a><br /></td></tr>
<tr class="separator:a802535b5fb6144e54a83051f7b612b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac731631b840bb6853af793ecc8b96253"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#ac731631b840bb6853af793ecc8b96253">add_associated_let_stmt</a> (std::string access_name, <a class="el" href="classtiramisu_1_1expr.html">tiramisu::expr</a> e)</td></tr>
<tr class="memdesc:ac731631b840bb6853af793ecc8b96253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a let statement that is associated to this computation.  <a href="#ac731631b840bb6853af793ecc8b96253">More...</a><br /></td></tr>
<tr class="separator:ac731631b840bb6853af793ecc8b96253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a86368777b0702e4c04981f82056329"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a2a86368777b0702e4c04981f82056329">add_definitions</a> (std::string iteration_domain_str, <a class="el" href="classtiramisu_1_1expr.html">tiramisu::expr</a> e, bool schedule_this_computation, <a class="el" href="namespacetiramisu.html#adacb3196c1c6ddd14350580e70717354">tiramisu::primitive_t</a> t, <a class="el" href="classtiramisu_1_1function.html">tiramisu::function</a> *fct)</td></tr>
<tr class="memdesc:a2a86368777b0702e4c04981f82056329"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add definitions of computations that have the same name as this computation.  <a href="#a2a86368777b0702e4c04981f82056329">More...</a><br /></td></tr>
<tr class="separator:a2a86368777b0702e4c04981f82056329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadcd659e4fabb0cce1562e4c1fe326e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#aadcd659e4fabb0cce1562e4c1fe326e7">add_predicate</a> (<a class="el" href="classtiramisu_1_1expr.html">tiramisu::expr</a> predicate)</td></tr>
<tr class="memdesc:aadcd659e4fabb0cce1562e4c1fe326e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a predicate (condition) on the computation.  <a href="#aadcd659e4fabb0cce1562e4c1fe326e7">More...</a><br /></td></tr>
<tr class="separator:aadcd659e4fabb0cce1562e4c1fe326e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27181748bece6f76f528982089951e0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a27181748bece6f76f528982089951e0d">after</a> (<a class="el" href="classtiramisu_1_1computation.html">computation</a> &amp;comp, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> iterator)</td></tr>
<tr class="memdesc:a27181748bece6f76f528982089951e0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule this computation to run after the computation <code>comp</code>.  <a href="#a27181748bece6f76f528982089951e0d">More...</a><br /></td></tr>
<tr class="separator:a27181748bece6f76f528982089951e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff7cfc17026f57393b1c315a686f5cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#aeff7cfc17026f57393b1c315a686f5cd">allocate_and_map_buffer_automatically</a> (<a class="el" href="namespacetiramisu.html#a0d83bca9b0437bcf906c15e170443aed">tiramisu::argument_t</a> type=<a class="el" href="namespacetiramisu.html#a0d83bca9b0437bcf906c15e170443aeda241ff08aa2bef135ac9f6691651244f5">tiramisu::a_temporary</a>)</td></tr>
<tr class="separator:aeff7cfc17026f57393b1c315a686f5cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c50e1fde5b2ebc3e27575d10448769"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a58c50e1fde5b2ebc3e27575d10448769">apply_transformation_on_schedule</a> (std::string map_str)</td></tr>
<tr class="memdesc:a58c50e1fde5b2ebc3e27575d10448769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a transformation on the schedule.  <a href="#a58c50e1fde5b2ebc3e27575d10448769">More...</a><br /></td></tr>
<tr class="separator:a58c50e1fde5b2ebc3e27575d10448769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc052433e6e1eb850e1df1f128986b60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#acc052433e6e1eb850e1df1f128986b60">between</a> (<a class="el" href="classtiramisu_1_1computation.html">computation</a> &amp;before_comp, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> before_l, <a class="el" href="classtiramisu_1_1computation.html">computation</a> &amp;after_comp, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> after_l)</td></tr>
<tr class="memdesc:acc052433e6e1eb850e1df1f128986b60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule this computation to run after <code>before_comp</code> at the loop level <code>before_l</code>, and before <code>after_comp</code> at loop level <code>after_l</code>.  <a href="#acc052433e6e1eb850e1df1f128986b60">More...</a><br /></td></tr>
<tr class="separator:acc052433e6e1eb850e1df1f128986b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b9d5764ae39e427bf252ba0ea736031"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a5b9d5764ae39e427bf252ba0ea736031">bind_to</a> (<a class="el" href="classtiramisu_1_1buffer.html">buffer</a> *buff)</td></tr>
<tr class="memdesc:a5b9d5764ae39e427bf252ba0ea736031"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind this computation to a buffer.  <a href="#a5b9d5764ae39e427bf252ba0ea736031">More...</a><br /></td></tr>
<tr class="separator:a5b9d5764ae39e427bf252ba0ea736031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b2f3533b7bc2cdfd7adeb524fa6aa0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#ac2b2f3533b7bc2cdfd7adeb524fa6aa0">compute_at</a> (<a class="el" href="classtiramisu_1_1computation.html">computation</a> &amp;consumer, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L)</td></tr>
<tr class="memdesc:ac2b2f3533b7bc2cdfd7adeb524fa6aa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function assumes that <code>consumer</code> consumes values produced by this computation (which is the producer).  <a href="#ac2b2f3533b7bc2cdfd7adeb524fa6aa0">More...</a><br /></td></tr>
<tr class="separator:ac2b2f3533b7bc2cdfd7adeb524fa6aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a446c0c602a7673ef570c22b3aea12418"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a446c0c602a7673ef570c22b3aea12418">dump_iteration_domain</a> () const</td></tr>
<tr class="memdesc:a446c0c602a7673ef570c22b3aea12418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump the iteration domain of the computation.  <a href="#a446c0c602a7673ef570c22b3aea12418">More...</a><br /></td></tr>
<tr class="separator:a446c0c602a7673ef570c22b3aea12418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91fa8307b68adb1bdabed79aab472784"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a91fa8307b68adb1bdabed79aab472784">dump_schedule</a> () const</td></tr>
<tr class="memdesc:a91fa8307b68adb1bdabed79aab472784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump the schedule of the computation.  <a href="#a91fa8307b68adb1bdabed79aab472784">More...</a><br /></td></tr>
<tr class="separator:a91fa8307b68adb1bdabed79aab472784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf3bcacb862bf8e45183dab3adf23f4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#abf3bcacb862bf8e45183dab3adf23f4c">dump</a> () const</td></tr>
<tr class="memdesc:abf3bcacb862bf8e45183dab3adf23f4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump the computation on stdout.  <a href="#abf3bcacb862bf8e45183dab3adf23f4c">More...</a><br /></td></tr>
<tr class="separator:abf3bcacb862bf8e45183dab3adf23f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22df51bf61d7a9215c5ba183eb479be3"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a22df51bf61d7a9215c5ba183eb479be3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a22df51bf61d7a9215c5ba183eb479be3">fuse_after</a> (<a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> lev, <a class="el" href="classtiramisu_1_1computation.html">computation</a> &amp;comp)</td></tr>
<tr class="memdesc:a22df51bf61d7a9215c5ba183eb479be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fuse this computation with the computation passed as argument in the same loop.  <a href="#a22df51bf61d7a9215c5ba183eb479be3">More...</a><br /></td></tr>
<tr class="separator:a22df51bf61d7a9215c5ba183eb479be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6459ca96b07ed425c01f7414e8b802ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a6459ca96b07ed425c01f7414e8b802ee">gen_time_space_domain</a> ()</td></tr>
<tr class="memdesc:a6459ca96b07ed425c01f7414e8b802ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the time-space domain of the computation.  <a href="#a6459ca96b07ed425c01f7414e8b802ee">More...</a><br /></td></tr>
<tr class="separator:a6459ca96b07ed425c01f7414e8b802ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf88c717f96910fe88eec0d1c3951287"><td class="memItemLeft" align="right" valign="top">isl_set *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#aaf88c717f96910fe88eec0d1c3951287">get_iteration_domain</a> () const</td></tr>
<tr class="memdesc:aaf88c717f96910fe88eec0d1c3951287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the iteration domain of the computation.  <a href="#aaf88c717f96910fe88eec0d1c3951287">More...</a><br /></td></tr>
<tr class="separator:aaf88c717f96910fe88eec0d1c3951287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f2d40251b2e238ca21e0bb75f1a0bb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtiramisu_1_1computation.html">tiramisu::computation</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a8f2d40251b2e238ca21e0bb75f1a0bb9">get_last_update</a> ()</td></tr>
<tr class="memdesc:a8f2d40251b2e238ca21e0bb75f1a0bb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last update of a computation.  <a href="#a8f2d40251b2e238ca21e0bb75f1a0bb9">More...</a><br /></td></tr>
<tr class="separator:a8f2d40251b2e238ca21e0bb75f1a0bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeedbe74d3ed8336ac3f6e031877b5208"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtiramisu_1_1computation.html">computation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#aeedbe74d3ed8336ac3f6e031877b5208">get_predecessor</a> ()</td></tr>
<tr class="memdesc:aeedbe74d3ed8336ac3f6e031877b5208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the computation scheduled immediately before this computation, or a null pointer if none exist.  <a href="#aeedbe74d3ed8336ac3f6e031877b5208">More...</a><br /></td></tr>
<tr class="separator:aeedbe74d3ed8336ac3f6e031877b5208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164265c5ca09e16c173a332beec66db6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtiramisu_1_1computation.html">tiramisu::computation</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a164265c5ca09e16c173a332beec66db6">get_update</a> (int index)</td></tr>
<tr class="memdesc:a164265c5ca09e16c173a332beec66db6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <code>index</code> update that has been added to this computation such that:  <a href="#a164265c5ca09e16c173a332beec66db6">More...</a><br /></td></tr>
<tr class="separator:a164265c5ca09e16c173a332beec66db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2cf3a0bf95da02e3b61831d1bdbdc70"><td class="memItemLeft" align="right" valign="top">isl_map *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#af2cf3a0bf95da02e3b61831d1bdbdc70">get_schedule</a> () const</td></tr>
<tr class="memdesc:af2cf3a0bf95da02e3b61831d1bdbdc70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the schedule of the computation.  <a href="#af2cf3a0bf95da02e3b61831d1bdbdc70">More...</a><br /></td></tr>
<tr class="separator:af2cf3a0bf95da02e3b61831d1bdbdc70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc26ee002088f750f872e6747f9582cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtiramisu_1_1buffer.html">tiramisu::buffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#afc26ee002088f750f872e6747f9582cf">get_automatically_allocated_buffer</a> ()</td></tr>
<tr class="memdesc:afc26ee002088f750f872e6747f9582cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the buffer that was allocated automatically using high level data mapping functions.  <a href="#afc26ee002088f750f872e6747f9582cf">More...</a><br /></td></tr>
<tr class="separator:afc26ee002088f750f872e6747f9582cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3370d2b63da2c87438a7d6da92afc0e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a3370d2b63da2c87438a7d6da92afc0e5">interchange</a> (<a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L0, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L1)</td></tr>
<tr class="memdesc:a3370d2b63da2c87438a7d6da92afc0e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interchange (swap) the two loop levels <code>L0</code> and <code>L1</code>.  <a href="#a3370d2b63da2c87438a7d6da92afc0e5">More...</a><br /></td></tr>
<tr class="separator:a3370d2b63da2c87438a7d6da92afc0e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bb92906d4541d1ab073bf9a164bc31c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a4bb92906d4541d1ab073bf9a164bc31c">mark_as_let_statement</a> ()</td></tr>
<tr class="memdesc:a4bb92906d4541d1ab073bf9a164bc31c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark this statement as a let statement.  <a href="#a4bb92906d4541d1ab073bf9a164bc31c">More...</a><br /></td></tr>
<tr class="separator:a4bb92906d4541d1ab073bf9a164bc31c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c748331b7a5d0c111c1bb24928ec771"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a0c748331b7a5d0c111c1bb24928ec771">parallelize</a> (<a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L)</td></tr>
<tr class="memdesc:a0c748331b7a5d0c111c1bb24928ec771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag the loop level <code>L</code> to be parallelized.  <a href="#a0c748331b7a5d0c111c1bb24928ec771">More...</a><br /></td></tr>
<tr class="separator:a0c748331b7a5d0c111c1bb24928ec771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc5d65959a7499510d81a0bafe9a078d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#abc5d65959a7499510d81a0bafe9a078d">set_expression</a> (const <a class="el" href="classtiramisu_1_1expr.html">tiramisu::expr</a> &amp;e)</td></tr>
<tr class="memdesc:abc5d65959a7499510d81a0bafe9a078d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the expression of the computation.  <a href="#abc5d65959a7499510d81a0bafe9a078d">More...</a><br /></td></tr>
<tr class="separator:abc5d65959a7499510d81a0bafe9a078d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cca4650b13a542a52b12a300e35bc92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a1cca4650b13a542a52b12a300e35bc92">set_inline</a> (bool is_inline=true)</td></tr>
<tr class="memdesc:a1cca4650b13a542a52b12a300e35bc92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether the computation is inline or not, based on the value of <code>is_inline</code>.  <a href="#a1cca4650b13a542a52b12a300e35bc92">More...</a><br /></td></tr>
<tr class="separator:a1cca4650b13a542a52b12a300e35bc92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d6e07e4f840d1c8d1ca74f925e3202"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a34d6e07e4f840d1c8d1ca74f925e3202">is_inline_computation</a> () const</td></tr>
<tr class="memdesc:a34d6e07e4f840d1c8d1ca74f925e3202"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if and only if the computation is inline.  <a href="#a34d6e07e4f840d1c8d1ca74f925e3202">More...</a><br /></td></tr>
<tr class="separator:a34d6e07e4f840d1c8d1ca74f925e3202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e0c7011fba7e94bb836e7e5f1a55261"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a8e0c7011fba7e94bb836e7e5f1a55261">shift</a> (<a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L0, int n)</td></tr>
<tr class="memdesc:a8e0c7011fba7e94bb836e7e5f1a55261"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift the loop level <code>L0</code> of the iteration space by <code>n</code> iterations.  <a href="#a8e0c7011fba7e94bb836e7e5f1a55261">More...</a><br /></td></tr>
<tr class="separator:a8e0c7011fba7e94bb836e7e5f1a55261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a718678aa2f3dfddc06fbd6760db9c12f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a718678aa2f3dfddc06fbd6760db9c12f">storage_fold</a> (<a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> dim, int f)</td></tr>
<tr class="memdesc:a718678aa2f3dfddc06fbd6760db9c12f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fold the storage of the computation.  <a href="#a718678aa2f3dfddc06fbd6760db9c12f">More...</a><br /></td></tr>
<tr class="separator:a718678aa2f3dfddc06fbd6760db9c12f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab741d4c5e5dfd5bc0f079fdd681196da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtiramisu_1_1computation.html">tiramisu::computation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#ab741d4c5e5dfd5bc0f079fdd681196da">store_at</a> (<a class="el" href="classtiramisu_1_1computation.html">tiramisu::computation</a> &amp;comp, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L0)</td></tr>
<tr class="memdesc:ab741d4c5e5dfd5bc0f079fdd681196da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate the storage of this computation in the loop level <code>L0</code>.  <a href="#ab741d4c5e5dfd5bc0f079fdd681196da">More...</a><br /></td></tr>
<tr class="separator:ab741d4c5e5dfd5bc0f079fdd681196da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ba81bf0611bb2f058ae7659fefd561"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a37ba81bf0611bb2f058ae7659fefd561">tag_parallel_level</a> (<a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L)</td></tr>
<tr class="memdesc:a37ba81bf0611bb2f058ae7659fefd561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag the loop level <code>L</code> to be parallelized.  <a href="#a37ba81bf0611bb2f058ae7659fefd561">More...</a><br /></td></tr>
<tr class="separator:a37ba81bf0611bb2f058ae7659fefd561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1c88a897e6ebd7c6e9b7bf0a35c963"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a6b1c88a897e6ebd7c6e9b7bf0a35c963">tag_vector_level</a> (<a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L, int len)</td></tr>
<tr class="memdesc:a6b1c88a897e6ebd7c6e9b7bf0a35c963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag the loop level <code>L</code> to be vectorized.  <a href="#a6b1c88a897e6ebd7c6e9b7bf0a35c963">More...</a><br /></td></tr>
<tr class="separator:a6b1c88a897e6ebd7c6e9b7bf0a35c963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab7d0d28bfc5cef46d45483bc1c6385"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a2ab7d0d28bfc5cef46d45483bc1c6385">tag_unroll_level</a> (<a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L)</td></tr>
<tr class="memdesc:a2ab7d0d28bfc5cef46d45483bc1c6385"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag the loop level <code>L</code> to be unrolled.  <a href="#a2ab7d0d28bfc5cef46d45483bc1c6385">More...</a><br /></td></tr>
<tr class="separator:a2ab7d0d28bfc5cef46d45483bc1c6385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2349d24241e2743e5fcdec1f2b70ff29"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a2349d24241e2743e5fcdec1f2b70ff29"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtiramisu_1_1expr.html">tiramisu::expr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a2349d24241e2743e5fcdec1f2b70ff29">operator()</a> (Args... args)</td></tr>
<tr class="memdesc:a2349d24241e2743e5fcdec1f2b70ff29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access operator: C0(i,j) represents an access to the element (i,j) of the computation C0.  <a href="#a2349d24241e2743e5fcdec1f2b70ff29">More...</a><br /></td></tr>
<tr class="separator:a2349d24241e2743e5fcdec1f2b70ff29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab20ae0ad5898c983c07f8fdf7539d754"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#ab20ae0ad5898c983c07f8fdf7539d754">before</a> (<a class="el" href="classtiramisu_1_1computation.html">computation</a> &amp;consumer, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L)</td></tr>
<tr class="memdesc:ab20ae0ad5898c983c07f8fdf7539d754"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule this computation to run before the computation <code>consumer</code> at the loop level <code>L</code>.  <a href="#ab20ae0ad5898c983c07f8fdf7539d754">More...</a><br /></td></tr>
<tr class="separator:ab20ae0ad5898c983c07f8fdf7539d754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a9ab5a1055aba6dd921819da184e9862b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a9ab5a1055aba6dd921819da184e9862b">gpu_tile</a> (<a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L0, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L1, int sizeX, int sizeY)</td></tr>
<tr class="memdesc:a9ab5a1055aba6dd921819da184e9862b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tile the computation and then tag the outermost tile dimension to be mapped to GPU blocks and tag the innermost tile dimensions to be mapped to GPU threads.  <a href="#a9ab5a1055aba6dd921819da184e9862b">More...</a><br /></td></tr>
<tr class="separator:a9ab5a1055aba6dd921819da184e9862b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf69c837e5565afb53a1f241e1f3c97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#aaaf69c837e5565afb53a1f241e1f3c97">gpu_tile</a> (<a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L0, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L1, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L2, int sizeX, int sizeY, int sizeZ)</td></tr>
<tr class="memdesc:aaaf69c837e5565afb53a1f241e1f3c97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tile the computation and then tag the outermost tile dimension to be mapped to GPU blocks and tag the innermost tile dimensions to be mapped to GPU threads.  <a href="#aaaf69c837e5565afb53a1f241e1f3c97">More...</a><br /></td></tr>
<tr class="separator:aaaf69c837e5565afb53a1f241e1f3c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a7f412d1ba941c990f18225d43f0fb621"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a7f412d1ba941c990f18225d43f0fb621">set_access</a> (std::string access_str)</td></tr>
<tr class="memdesc:a7f412d1ba941c990f18225d43f0fb621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the access relation of the computation.  <a href="#a7f412d1ba941c990f18225d43f0fb621">More...</a><br /></td></tr>
<tr class="separator:a7f412d1ba941c990f18225d43f0fb621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a981e28763928d5faa066f9350b9547dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a981e28763928d5faa066f9350b9547dc">set_access</a> (isl_map *access)</td></tr>
<tr class="memdesc:a981e28763928d5faa066f9350b9547dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the access relation of the computation.  <a href="#a981e28763928d5faa066f9350b9547dc">More...</a><br /></td></tr>
<tr class="separator:a981e28763928d5faa066f9350b9547dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a73950403fb75df11351e34baa830c8e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a73950403fb75df11351e34baa830c8e4">set_low_level_schedule</a> (isl_map *map)</td></tr>
<tr class="memdesc:a73950403fb75df11351e34baa830c8e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the schedule indicated by <code>map</code>.  <a href="#a73950403fb75df11351e34baa830c8e4">More...</a><br /></td></tr>
<tr class="separator:a73950403fb75df11351e34baa830c8e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65cb781f866beb35776a60b7e8c095dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a65cb781f866beb35776a60b7e8c095dc">set_low_level_schedule</a> (std::string map_str)</td></tr>
<tr class="memdesc:a65cb781f866beb35776a60b7e8c095dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the schedule indicated by <code>map</code>.  <a href="#a65cb781f866beb35776a60b7e8c095dc">More...</a><br /></td></tr>
<tr class="separator:a65cb781f866beb35776a60b7e8c095dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a71ba41faf9403d2db864c886db0301d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a71ba41faf9403d2db864c886db0301d4">split</a> (<a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L0, int sizeX)</td></tr>
<tr class="memdesc:a71ba41faf9403d2db864c886db0301d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the loop level <code>L0</code> of the iteration space into two new loop levels.  <a href="#a71ba41faf9403d2db864c886db0301d4">More...</a><br /></td></tr>
<tr class="separator:a71ba41faf9403d2db864c886db0301d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6781ec005a7e9696b77f06d29d0d8e14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a6781ec005a7e9696b77f06d29d0d8e14">split</a> (<a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L0, int sizeX, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L0_outer, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L0_inner)</td></tr>
<tr class="memdesc:a6781ec005a7e9696b77f06d29d0d8e14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the loop level <code>L0</code> of the iteration space into two new loop levels.  <a href="#a6781ec005a7e9696b77f06d29d0d8e14">More...</a><br /></td></tr>
<tr class="separator:a6781ec005a7e9696b77f06d29d0d8e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a12cf0a03413b4be996c62c1ea61f5d8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a12cf0a03413b4be996c62c1ea61f5d8d">tag_gpu_level</a> (<a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L0, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L1)</td></tr>
<tr class="memdesc:a12cf0a03413b4be996c62c1ea61f5d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag the loop level <code>L0</code> and <code>L1</code> to be mapped to GPU.  <a href="#a12cf0a03413b4be996c62c1ea61f5d8d">More...</a><br /></td></tr>
<tr class="separator:a12cf0a03413b4be996c62c1ea61f5d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4fb03cd144ca7282b5fbcf3a5aeb32e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#ae4fb03cd144ca7282b5fbcf3a5aeb32e">tag_gpu_level</a> (<a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L0, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L1, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L2, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L3)</td></tr>
<tr class="memdesc:ae4fb03cd144ca7282b5fbcf3a5aeb32e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag the loop level <code>L0</code> and <code>L1</code> to be mapped to GPU.  <a href="#ae4fb03cd144ca7282b5fbcf3a5aeb32e">More...</a><br /></td></tr>
<tr class="separator:ae4fb03cd144ca7282b5fbcf3a5aeb32e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab21a3469f5925d109b1f850ea9a9dd57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#ab21a3469f5925d109b1f850ea9a9dd57">tag_gpu_level</a> (<a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L0, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L1, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L2, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L3, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L4, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L5)</td></tr>
<tr class="memdesc:ab21a3469f5925d109b1f850ea9a9dd57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag the loop level <code>L0</code> and <code>L1</code> to be mapped to GPU.  <a href="#ab21a3469f5925d109b1f850ea9a9dd57">More...</a><br /></td></tr>
<tr class="separator:ab21a3469f5925d109b1f850ea9a9dd57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a0fc402b23a4d138cd21eda8e041a8a03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a0fc402b23a4d138cd21eda8e041a8a03">tile</a> (<a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L0, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L1, int sizeX, int sizeY)</td></tr>
<tr class="memdesc:a0fc402b23a4d138cd21eda8e041a8a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tile the two loop levels <code>L0</code> and <code>L1</code> with rectangular tiling.  <a href="#a0fc402b23a4d138cd21eda8e041a8a03">More...</a><br /></td></tr>
<tr class="separator:a0fc402b23a4d138cd21eda8e041a8a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a63c66e3db24bd85b1ffe7b23822c6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a5a63c66e3db24bd85b1ffe7b23822c6c">tile</a> (<a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L0, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L1, int sizeX, int sizeY, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L0_outer, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L1_outer, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L0_inner, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L1_inner)</td></tr>
<tr class="memdesc:a5a63c66e3db24bd85b1ffe7b23822c6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tile the two loop levels <code>L0</code> and <code>L1</code> with rectangular tiling.  <a href="#a5a63c66e3db24bd85b1ffe7b23822c6c">More...</a><br /></td></tr>
<tr class="separator:a5a63c66e3db24bd85b1ffe7b23822c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae37bc997ad3dacfd4bea812c068b87ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#ae37bc997ad3dacfd4bea812c068b87ff">tile</a> (<a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L0, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L1, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L2, int sizeX, int sizeY, int sizeZ)</td></tr>
<tr class="memdesc:ae37bc997ad3dacfd4bea812c068b87ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tile the two loop levels <code>L0</code> and <code>L1</code> with rectangular tiling.  <a href="#ae37bc997ad3dacfd4bea812c068b87ff">More...</a><br /></td></tr>
<tr class="separator:ae37bc997ad3dacfd4bea812c068b87ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b17318417cb0d0419f66bf8fb742246"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a8b17318417cb0d0419f66bf8fb742246">tile</a> (<a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L0, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L1, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L2, int sizeX, int sizeY, int sizeZ, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L0_outer, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L1_outer, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L2_outer, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L0_inner, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L1_inner, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L2_inner)</td></tr>
<tr class="memdesc:a8b17318417cb0d0419f66bf8fb742246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tile the two loop levels <code>L0</code> and <code>L1</code> with rectangular tiling.  <a href="#a8b17318417cb0d0419f66bf8fb742246">More...</a><br /></td></tr>
<tr class="separator:a8b17318417cb0d0419f66bf8fb742246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a68cc2dc757dfb181548b739c901ed6f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a68cc2dc757dfb181548b739c901ed6f9">unroll</a> (<a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L, int fac)</td></tr>
<tr class="memdesc:a68cc2dc757dfb181548b739c901ed6f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unroll the loop level <code>L</code> with an unrolling factor <code>fac</code>.  <a href="#a68cc2dc757dfb181548b739c901ed6f9">More...</a><br /></td></tr>
<tr class="separator:a68cc2dc757dfb181548b739c901ed6f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a566d1284eef9d999112660a3fff30561"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a566d1284eef9d999112660a3fff30561">unroll</a> (<a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L, int fac, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L_outer, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L_inner)</td></tr>
<tr class="memdesc:a566d1284eef9d999112660a3fff30561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unroll the loop level <code>L</code> with an unrolling factor <code>fac</code>.  <a href="#a566d1284eef9d999112660a3fff30561">More...</a><br /></td></tr>
<tr class="separator:a566d1284eef9d999112660a3fff30561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:abfb52d2e77fd1157343350a01fe905ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#abfb52d2e77fd1157343350a01fe905ab">vectorize</a> (<a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L, int v)</td></tr>
<tr class="memdesc:abfb52d2e77fd1157343350a01fe905ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorize the loop level <code>L</code>.  <a href="#abfb52d2e77fd1157343350a01fe905ab">More...</a><br /></td></tr>
<tr class="separator:abfb52d2e77fd1157343350a01fe905ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f4dd685fd931af56ba633fef4b184b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#ac7f4dd685fd931af56ba633fef4b184b">vectorize</a> (<a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L, int v, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L_outer, <a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a> L_inner)</td></tr>
<tr class="memdesc:ac7f4dd685fd931af56ba633fef4b184b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorize the loop level <code>L</code>.  <a href="#ac7f4dd685fd931af56ba633fef4b184b">More...</a><br /></td></tr>
<tr class="separator:ac7f4dd685fd931af56ba633fef4b184b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a7b874384f567f7bbf60bbf58f86e6ddc"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classtiramisu_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#a7b874384f567f7bbf60bbf58f86e6ddc">root</a></td></tr>
<tr class="memdesc:a7b874384f567f7bbf60bbf58f86e6ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">root_dimension is a number used to specify the dimension level known as root.  <a href="#a7b874384f567f7bbf60bbf58f86e6ddc">More...</a><br /></td></tr>
<tr class="separator:a7b874384f567f7bbf60bbf58f86e6ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e56982ea734feb3dc1670969ff617d"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtiramisu_1_1computation.html#ab8e56982ea734feb3dc1670969ff617d">root_dimension</a> = -1</td></tr>
<tr class="memdesc:ab8e56982ea734feb3dc1670969ff617d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="classtiramisu_1_1computation.html#a7b874384f567f7bbf60bbf58f86e6ddc" title="root_dimension is a number used to specify the dimension level known as root. ">computation::root</a> but to be used with scheduling functions that take loop level (integers) as input instead of <a class="el" href="classtiramisu_1_1var.html" title="A class that represents constant variable references. ">tiramisu::var</a>.  <a href="#ab8e56982ea734feb3dc1670969ff617d">More...</a><br /></td></tr>
<tr class="separator:ab8e56982ea734feb3dc1670969ff617d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class that represents computations. </p>
<p>A computation is an expression associated with an iteration domain. A computation indicates what needs to be computed (the expression that should be computed). A computation has three representations:</p><ul>
<li>Level I: this level specifies "what" should be computed but does not specify "when" (order) and "where" (on which processor) each expression should be computed. This level also does not specify where computations should be stored in memory and in which data layout.</li>
<li>Level II: this level specifies "what" should be computed, "when", i.e. the order in which the computation should be executed with regard to the other computations. And "where" each computation should be computed (i.e., on which processor). This level still does not specify where computations should be stored in memory and their data layout.</li>
<li>Level III: this level is similar to Level 2 but it specifies where computations should be stored in memory and the data layout. </li>
</ul>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorials_2tutorial_01_8cpp-example.html#_a4">tutorials/tutorial_01.cpp</a>, <a class="el" href="tutorials_2tutorial_02_8cpp-example.html#_a5">tutorials/tutorial_02.cpp</a>, <a class="el" href="tutorials_2tutorial_03_8cpp-example.html#_a5">tutorials/tutorial_03.cpp</a>, <a class="el" href="tutorials_2tutorial_04_8cpp-example.html#_a5">tutorials/tutorial_04.cpp</a>, <a class="el" href="tutorials_2tutorial_05_8cpp-example.html#_a5">tutorials/tutorial_05.cpp</a>, and <a class="el" href="tutorials_2tutorial_06_8cpp-example.html#_a7">tutorials/tutorial_06.cpp</a>.</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="core_8h_source.html#l01140">1140</a> of file <a class="el" href="core_8h_source.html">core.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a802535b5fb6144e54a83051f7b612b86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a802535b5fb6144e54a83051f7b612b86">&#9670;&nbsp;</a></span>computation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tiramisu::computation::computation </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>iteration_domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1expr.html">tiramisu::expr</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>schedule_this_computation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetiramisu.html#adacb3196c1c6ddd14350580e70717354">tiramisu::primitive_t</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1function.html">tiramisu::function</a> *&#160;</td>
          <td class="paramname"><em>fct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for computations. </p>
<p><code>iteration_domain</code> is a string that represents the iteration domain of the computation. The iteration domain should be written in the ISL format (<a href="http://barvinok.gforge.inria.fr/barvinok.pdf">http://barvinok.gforge.inria.fr/barvinok.pdf</a> Section 1.2.1).</p>
<p>The iteration domain of a statement is a set that contains all of the execution instances of the statement (a statement in a loop has an execution instance for each loop iteration in which it executes). Each execution instance of a statement in a loop nest is uniquely represented by an identifier and a tuple of integers (typically, the values of the outer loop iterators).</p>
<p>For example, the iteration space of the statement S0 in the following loop nest</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i=0; i&lt;2; i++)</div><div class="line">  <span class="keywordflow">for</span> (j=0; j&lt;3; j++)</div><div class="line">     S0;</div></div><!-- fragment --><p>is {S0[0,0], S0[0,1], S0[0,2], S0[1,0], S0[1,1], S0[1,2]}</p>
<p>S0[0,0] is the execution instance of S0 in the iteration [0,0].</p>
<p>The previous set of integer tuples can be compactly described by affine constraints as follows</p>
<p>{S0[i,j]: 0&lt;=i&lt;2 and 0&lt;=j&lt;3}</p>
<p>In general, the loop nest</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i=0; i&lt;N; i++)</div><div class="line">  <span class="keywordflow">for</span> (j=0; j&lt;M; j++)</div><div class="line">     S0;</div></div><!-- fragment --><p>has the following iteration domain</p>
<p>{S0[i,j]: 0&lt;=i&lt;N and 0&lt;=j&lt;M}</p>
<p>This should be read as: the set of points [i,j] such that 0&lt;=i&lt;N and 0&lt;=j&lt;M.</p>
<p>The name of the computation in the iteration domain should not start with _ (an underscore). Names starting with _ are reserved names.</p>
<p><code>e</code> is the expression computed by the computation. It is possible to declare the computation without specifying the expression. The expression can be specified later using <a class="el" href="classtiramisu_1_1computation.html#abc5d65959a7499510d81a0bafe9a078d" title="Set the expression of the computation. ">computation::set_expression()</a>. An example of setting the expression after declaring the computation is presented in tests/test_04.cpp.</p>
<p><code>schedule_this_computation</code> should be set to true if the computation is supposed to be schedule and code is supposed to be generated from the computation. Set it to false if you just want to use the computation to represent a buffer (that is passed as an argument to the function) and you do not intend to generate code for the computation. An example where this argument is set to false is presented in tests/test_14.cpp.</p>
<p><code>t</code> is the type of the computation, i.e. the type of the expression computed by the computation. Example of types include (p_uint8, p_uint16, p_uint32, ...).</p>
<p><code>fct</code> is a pointer to the Tiramisu function where this computation should be added.</p>
<p>Bound Inference: The user can declare computations without providing any constraint about the iteration domain, in this case he can rely on bound inference to infer the constraints about each iteration domain. The user needs only to provide constraints over the domains of the last computations (last consumers), and Tiramisu will propagate these constraints to all the chain of computations that precede those consumers. Note that bound inference is not possible if you have multiple definitions of the same computation. In such a case, you should provide constraints over the iteration domain when you declare the computation.</p>
<p>Examples about bound inference are provided in test_22 to test_25. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac731631b840bb6853af793ecc8b96253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac731631b840bb6853af793ecc8b96253">&#9670;&nbsp;</a></span>add_associated_let_stmt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::add_associated_let_stmt </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>access_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1expr.html">tiramisu::expr</a>&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a let statement that is associated to this computation. </p>
<p>The let statement will be executed before the computation (more precisely, between this computation and any computation that preceeds it). The variable defined by the let statement can be accessible by this computation alone. i.e., it cannot be used in any other computation. </p>

</div>
</div>
<a id="a2a86368777b0702e4c04981f82056329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a86368777b0702e4c04981f82056329">&#9670;&nbsp;</a></span>add_definitions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::add_definitions </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>iteration_domain_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1expr.html">tiramisu::expr</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>schedule_this_computation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetiramisu.html#adacb3196c1c6ddd14350580e70717354">tiramisu::primitive_t</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1function.html">tiramisu::function</a> *&#160;</td>
          <td class="paramname"><em>fct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add definitions of computations that have the same name as this computation. </p>
<p>The arguments of this function are identical to the arguments of the computation constructor. In general, this function is used to express reductions and to express computation updates.</p>
<p>In other words, this function should be used if the user has already declared a set of computations C and wants to declare more computations that have the same name.</p>
<p>Example: Let's assume we want to declare the following two computations.</p>
<div class="fragment"><div class="line"><span class="comment">// First computation</span></div><div class="line">{C[i]: 0&lt;=i&lt;10}: 0</div><div class="line"></div><div class="line"><span class="comment">// Second computation</span></div><div class="line">{C[i]: 10&lt;=i&lt;20}: 1</div></div><!-- fragment --><p>To do this this, we can declare the first computation using the computation constructor and declare the second computation using <a class="el" href="classtiramisu_1_1computation.html#a2a86368777b0702e4c04981f82056329" title="Add definitions of computations that have the same name as this computation. ">add_definitions()</a>.</p>
<p>The use of add_computation is purely due to restrictions imposed by the C++ language and not by the Tiramisu framework itself. This is mainly because in C++, it is not possible to declare two objects with the same name, for example one cannot do</p>
<p>computation C(...); computation C(...);</p>
<p>In order to declare the second set of computations, we chose to use the add_definitions function to avoid this problem.</p>
<p>The newly added computations must have the same name and the same access function as the initial set of computations but can have a different expression.</p>
<p>An example of using this function is available in test_26. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorials_2tutorial_03_8cpp-example.html#a8">tutorials/tutorial_03.cpp</a>, and <a class="el" href="tutorials_2tutorial_06_8cpp-example.html#a9">tutorials/tutorial_06.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="aadcd659e4fabb0cce1562e4c1fe326e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadcd659e4fabb0cce1562e4c1fe326e7">&#9670;&nbsp;</a></span>add_predicate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::add_predicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1expr.html">tiramisu::expr</a>&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a predicate (condition) on the computation. </p>
<p>The computation will be executed only if this condition is true.</p>
<p>The predicate can be an affine or a non-affine expression. If you need to put a condition around a block of statements (i.e., a sequence of computations), then you can perform that by adding a predicate to each one of those computations. The compiler will then transform automatically the multiple conditions (condition around each computation) into one condition around the whole block. </p>

</div>
</div>
<a id="a27181748bece6f76f528982089951e0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27181748bece6f76f528982089951e0d">&#9670;&nbsp;</a></span>after()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::after </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1computation.html">computation</a> &amp;&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>iterator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule this computation to run after the computation <code>comp</code>. </p>
<p>This computation is placed after <code>comp</code> in the loop level <code>level</code>. <code>level</code> is a loop level in this computation.</p>
<p>The root level is <a class="el" href="classtiramisu_1_1computation.html#a7b874384f567f7bbf60bbf58f86e6ddc" title="root_dimension is a number used to specify the dimension level known as root. ">computation::root</a>.</p>
<p>For example assuming we have the two computations </p><pre class="fragment">{S0[i,j]: 0&lt;=i&lt;N and 0&lt;=j&lt;N} and {S1[i,j]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}
</pre><p>In order to make S1 run after S0 in the i loop, one should use </p><pre class="fragment">S1.after(S0, i)
</pre><p>which means: S1 is after S0 at the loop level i (which is loop level 0).</p>
<p>The corresponding code is</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i=0; i&lt;N; i++)</div><div class="line">{</div><div class="line">    <span class="keywordflow">for</span> (j=0; j&lt;N; j++)</div><div class="line">        S0;</div><div class="line">    <span class="keywordflow">for</span> (j=0; j&lt;N; j++)</div><div class="line">        S1;</div><div class="line">}</div></div><!-- fragment --><p>S1.after(S0, j)</p>
<p>means: S1 is after S0 at the loop level j (which is 1) and would yield the following code</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i=0; i&lt;N; i++)</div><div class="line">  <span class="keywordflow">for</span> (j=0; j&lt;N; j++)</div><div class="line">  {</div><div class="line">    S0;</div><div class="line">    S1;</div><div class="line">  }</div></div><!-- fragment --><p>S1.after(S0, computation::root) means S1 is after S0 at the main program level and would yield the following code</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i=0; i&lt;N; i++)</div><div class="line">  <span class="keywordflow">for</span> (j=0; j&lt;N; j++)</div><div class="line">    S0;</div><div class="line"><span class="keywordflow">for</span> (i=0; i&lt;N; i++)</div><div class="line">  <span class="keywordflow">for</span> (j=0; j&lt;N; j++)</div><div class="line">    S1;</div></div><!-- fragment --><p>Note that as with all other scheduling methods:</p><ul>
<li>Calling this method with the same computations overwrites the level if it is higher.</li>
<li>A computation being scheduled after another computation at level L means it is scheduled after that computation at all levels lower than L.</li>
<li>There should be exactly one computation with no computation scheduled before it.</li>
<li>Each other computation should have exactly one computation scheduled before it. </li>
</ul>

</div>
</div>
<a id="aeff7cfc17026f57393b1c315a686f5cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeff7cfc17026f57393b1c315a686f5cd">&#9670;&nbsp;</a></span>allocate_and_map_buffer_automatically()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::allocate_and_map_buffer_automatically </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetiramisu.html#a0d83bca9b0437bcf906c15e170443aed">tiramisu::argument_t</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="namespacetiramisu.html#a0d83bca9b0437bcf906c15e170443aeda241ff08aa2bef135ac9f6691651244f5">tiramisu::a_temporary</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a58c50e1fde5b2ebc3e27575d10448769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58c50e1fde5b2ebc3e27575d10448769">&#9670;&nbsp;</a></span>apply_transformation_on_schedule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::apply_transformation_on_schedule </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>map_str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a transformation on the schedule. </p>
<p>This transformation is from the time-space domain to the time-space domain. It is applied on the range of the schedule (i.e., on the output of the schedule relation).</p>
<p>For example, to shift the i dimension of the time-processor domain of C0, you can apply the transformation</p>
<p>C0[0, 0, i, 0, j, 0] -&gt; C0[0, 0, i+2, 0, j, 0]</p>
<p>To apply an interchange, you would do</p>
<p>C0[0, 0, i, 0, j, 0] -&gt; C0[0, 0, j, 0, i, 0] </p>

</div>
</div>
<a id="ab20ae0ad5898c983c07f8fdf7539d754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab20ae0ad5898c983c07f8fdf7539d754">&#9670;&nbsp;</a></span>before()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::before </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1computation.html">computation</a> &amp;&#160;</td>
          <td class="paramname"><em>consumer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule this computation to run before the computation <code>consumer</code> at the loop level <code>L</code>. </p>
<p>Notes</p><ul>
<li>The loop level <code>L</code> is a loop level of this computation.</li>
<li>Use <a class="el" href="classtiramisu_1_1computation.html#a7b874384f567f7bbf60bbf58f86e6ddc" title="root_dimension is a number used to specify the dimension level known as root. ">computation::root</a> to indicate the root dimension (i.e. the outermost time-space dimension).</li>
<li>Calling this method with the same computations overwrites the level if it is higher.</li>
<li>A computation being scheduled after another computation at level L means it is scheduled after that computation at all levels lower than L.</li>
<li>There should be exactly one computation with no computation scheduled before it.</li>
<li>Each other computation should have exactly one computation scheduled before it. </li>
</ul>

</div>
</div>
<a id="acc052433e6e1eb850e1df1f128986b60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc052433e6e1eb850e1df1f128986b60">&#9670;&nbsp;</a></span>between()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::between </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1computation.html">computation</a> &amp;&#160;</td>
          <td class="paramname"><em>before_comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>before_l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1computation.html">computation</a> &amp;&#160;</td>
          <td class="paramname"><em>after_comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>after_l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule this computation to run after <code>before_comp</code> at the loop level <code>before_l</code>, and before <code>after_comp</code> at loop level <code>after_l</code>. </p>
<p>The outermost loop level is 0.</p>
<p>Use <a class="el" href="classtiramisu_1_1computation.html#ab8e56982ea734feb3dc1670969ff617d" title="Equivalent of computation::root but to be used with scheduling functions that take loop level (intege...">computation::root_dimension</a> to indicate the root dimension (i.e. the outermost time-space dimension).</p>
<p>If there was already a direct scheduling between <code>before_comp</code> and <code>after_comp</code> (e.g. using before, after, between...), that schedule is overwritten; i.e. it no longer exists/has an effect.</p>
<p>Note that as with all other scheduling methods:</p><ul>
<li>Calling this method with the same computations overwrites the levels if they are higher.</li>
<li>A computation being scheduled after another computation at level L means it is scheduled after that computation at all levels lower than L.</li>
<li>There should be exactly one computation with no computation scheduled before it.</li>
<li>Each other computation should have exactly one computation scheduled before it. </li>
</ul>

</div>
</div>
<a id="a5b9d5764ae39e427bf252ba0ea736031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b9d5764ae39e427bf252ba0ea736031">&#9670;&nbsp;</a></span>bind_to()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::bind_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1buffer.html">buffer</a> *&#160;</td>
          <td class="paramname"><em>buff</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind this computation to a buffer. </p>
<p>i.e., create a one-to-one data mapping between the computation and the buffer.</p>
<p>In Tiramisu, a tiramisu computation cannot directly consume values from buffers. Buffers should first be wrapped in computations.</p>
<p>For example, a Tiramisu function receives a buffer b0 as input. Let's assume that this function has a computation C0 that adds 1 to the elements of the buffer. The user cannot use b0 directly in C0. He should first declare a computation that wraps b0 and then use that computation.</p>
<p>// the wrapper computation. Wrapper computation have empty expressions // attached to them. {wb0[i]: 0&lt;=i&lt;N}: expr()</p>
<p>// Declare the computation C0 that uses the wrapper wb0 {C0[i]: 0&lt;=i&lt;N}: wb0(i) + 1</p>
<p>// Bind the wrapper wb0 to the buffer b0. This binding means that // each element wb0[i] correspond to an element b0[i] in the buffer. wb0.bind_to(b0) </p>

</div>
</div>
<a id="ac2b2f3533b7bc2cdfd7adeb524fa6aa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2b2f3533b7bc2cdfd7adeb524fa6aa0">&#9670;&nbsp;</a></span>compute_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::compute_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1computation.html">computation</a> &amp;&#160;</td>
          <td class="paramname"><em>consumer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function assumes that <code>consumer</code> consumes values produced by this computation (which is the producer). </p>
<p>Compute this computation as needed for each unique value of the <code>consumer</code>.</p>
<p>This computation is scheduled so that the values consumed by the <code>consumer</code> are computed at the level <code>L</code> and in the same loop nest of the consumer.</p>
<p>If the consumer needs this computation to be computed redundantly, the function creates the necessary redundant computations and schedules them before the consumer.</p>
<p>This function performs the following:</p><ul>
<li>schedules this computation to be executed as needed before the consumer.</li>
<li>if this computation needs to be computed redundantly, redundant computations are create.</li>
</ul>
<p>This function does not:</p><ul>
<li>create any data mapping to this computation. It is up to the user to provide an access relation to this computation as he would do to any other normal computation.</li>
<li>it does not allocate any buffer to this computation. It is up to the user to declare a buffer where the results of this computation will be stored.</li>
</ul>
<p>If this functions creates a duplicate of the computation, the user does not need to set its access relation. The duplicated computation will automatically have the same access relation as the original computation. This access relation is set automatically.</p>
<p>This function does not return a handler to manipulate the duplicate computation. It does not allow the user to manipulate the duplicate freely. The duplicate is scheduled automatically to be executed before the consumer. </p>

</div>
</div>
<a id="abf3bcacb862bf8e45183dab3adf23f4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf3bcacb862bf8e45183dab3adf23f4c">&#9670;&nbsp;</a></span>dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::dump </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump the computation on stdout. </p>
<p>This is mainly useful for debugging. </p>

</div>
</div>
<a id="a446c0c602a7673ef570c22b3aea12418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a446c0c602a7673ef570c22b3aea12418">&#9670;&nbsp;</a></span>dump_iteration_domain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::dump_iteration_domain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump the iteration domain of the computation. </p>
<p>This is useful for debugging. </p>

</div>
</div>
<a id="a91fa8307b68adb1bdabed79aab472784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91fa8307b68adb1bdabed79aab472784">&#9670;&nbsp;</a></span>dump_schedule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::dump_schedule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump the schedule of the computation. </p>
<p>This is mainly useful for debugging.</p>
<p>The schedule is a relation between the iteration space and the time space. The relation provides a logical date of execution for each point in the iteration space. The schedule needs first to be set before calling this function. </p>

</div>
</div>
<a id="a22df51bf61d7a9215c5ba183eb479be3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22df51bf61d7a9215c5ba183eb479be3">&#9670;&nbsp;</a></span>fuse_after()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::fuse_after </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>lev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1computation.html">computation</a> &amp;&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fuse this computation with the computation passed as argument in the same loop. </p>
<p>Run this computation after that computation. Fuse them at the loop level <code>lev</code>.</p>
<p>For example, assuming we have the following computations</p>
<p>{S0[i,j]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}, {S1[i,j]: 0&lt;=i&lt;N and 0&lt;=j&lt;N} and {S2[i,j]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}.</p>
<p>Without fusion, these computations would be equivalent to the following loops nests</p>
<p>for (i=0; i&lt;N; i++) for (j=0; j&lt;N; j++) S0;</p>
<p>for (i=0; i&lt;N; i++) for (j=0; j&lt;N; j++) S1;</p>
<p>for (i=0; i&lt;N; i++) for (j=0; j&lt;N; j++) S2;</p>
<p>To fuse them, one should call</p>
<p>S2.fuse_after(j, S1); S1.fuse_after(j, S0);</p>
<p>This would result in fusing S2 with S0 and S1 at loop level j. S2 will be scheduled for execution after S0 and S1. The resulting code would look like</p>
<p>for (i=0; i&lt;N; i++) for (j=0; j&lt;N; j++) { S0; S1; S2; }</p>
<p>Calling</p>
<p>S2.fuse_after(i, S1); S1.fuse_after(i, S0);</p>
<p>would result in the following code</p>
<p>for (i=0; i&lt;N; i++) { for (j=0; j&lt;N; j++) S0; for (j=0; j&lt;N; j++) S1; for (j=0; j&lt;N; j++) S2; } </p>

<p class="definition">Definition at line <a class="el" href="core_8h_source.html#l02727">2727</a> of file <a class="el" href="core_8h_source.html">core.h</a>.</p>

<p class="reference">References <a class="el" href="expr_8h_source.html#l00670">tiramisu::expr::get_name()</a>.</p>

</div>
</div>
<a id="a6459ca96b07ed425c01f7414e8b802ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6459ca96b07ed425c01f7414e8b802ee">&#9670;&nbsp;</a></span>gen_time_space_domain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::gen_time_space_domain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the time-space domain of the computation. </p>
<p>In this representation, the logical time of execution and the processor where the computation will be executed are both specified. The memory location where computations will be stored in memory is not specified at the level. </p>

</div>
</div>
<a id="afc26ee002088f750f872e6747f9582cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc26ee002088f750f872e6747f9582cf">&#9670;&nbsp;</a></span>get_automatically_allocated_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiramisu_1_1buffer.html">tiramisu::buffer</a>* tiramisu::computation::get_automatically_allocated_buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the buffer that was allocated automatically using high level data mapping functions. </p>
<p>If no automatic buffer was allocated, this function returns NULL. </p>

</div>
</div>
<a id="aaf88c717f96910fe88eec0d1c3951287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf88c717f96910fe88eec0d1c3951287">&#9670;&nbsp;</a></span>get_iteration_domain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">isl_set* tiramisu::computation::get_iteration_domain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the iteration domain of the computation. </p>
<p>In this representation, the order of execution of computations is not specified, the computations are also not mapped to memory. </p>

</div>
</div>
<a id="a8f2d40251b2e238ca21e0bb75f1a0bb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f2d40251b2e238ca21e0bb75f1a0bb9">&#9670;&nbsp;</a></span>get_last_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiramisu_1_1computation.html">tiramisu::computation</a>&amp; tiramisu::computation::get_last_update </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the last update of a computation. </p>

</div>
</div>
<a id="aeedbe74d3ed8336ac3f6e031877b5208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeedbe74d3ed8336ac3f6e031877b5208">&#9670;&nbsp;</a></span>get_predecessor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiramisu_1_1computation.html">computation</a>* tiramisu::computation::get_predecessor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the computation scheduled immediately before this computation, or a null pointer if none exist. </p>

</div>
</div>
<a id="af2cf3a0bf95da02e3b61831d1bdbdc70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2cf3a0bf95da02e3b61831d1bdbdc70">&#9670;&nbsp;</a></span>get_schedule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">isl_map* tiramisu::computation::get_schedule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the schedule of the computation. </p>

</div>
</div>
<a id="a164265c5ca09e16c173a332beec66db6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a164265c5ca09e16c173a332beec66db6">&#9670;&nbsp;</a></span>get_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiramisu_1_1computation.html">tiramisu::computation</a>&amp; tiramisu::computation::get_update </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <code>index</code> update that has been added to this computation such that: </p>
<ul>
<li>If <code>index</code> == 0, then this computation is returned.</li>
<li>If <code>&gt;</code> 0, then it returns the pth computation added through add_definitions. </li>
</ul>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorials_2tutorial_03_8cpp-example.html#a9">tutorials/tutorial_03.cpp</a>, and <a class="el" href="tutorials_2tutorial_06_8cpp-example.html#a10">tutorials/tutorial_06.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="a9ab5a1055aba6dd921819da184e9862b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ab5a1055aba6dd921819da184e9862b">&#9670;&nbsp;</a></span>gpu_tile() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::gpu_tile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tile the computation and then tag the outermost tile dimension to be mapped to GPU blocks and tag the innermost tile dimensions to be mapped to GPU threads. </p>
<p>Tile the two loop levels <code>L0</code> and <code>L1</code> with rectangular tiling. <code>sizeX</code> and <code>sizeY</code> represent the tile size. <code>L0</code> and <code>L1</code> should be two consecutive loop levels (i.e., <code>L0</code> = <code>L1</code> + 1) and they should satisfy <code>L0</code> &gt; <code>L1</code>. </p>

</div>
</div>
<a id="aaaf69c837e5565afb53a1f241e1f3c97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaf69c837e5565afb53a1f241e1f3c97">&#9670;&nbsp;</a></span>gpu_tile() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::gpu_tile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeZ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tile the computation and then tag the outermost tile dimension to be mapped to GPU blocks and tag the innermost tile dimensions to be mapped to GPU threads. </p>
<p>Tile the two loop levels <code>L0</code> and <code>L1</code> with rectangular tiling. <code>sizeX</code> and <code>sizeY</code> represent the tile size. <code>L0</code> and <code>L1</code> should be two consecutive loop levels (i.e., <code>L0</code> = <code>L1</code> + 1) and they should satisfy <code>L0</code> &gt; <code>L1</code>. </p>

</div>
</div>
<a id="a3370d2b63da2c87438a7d6da92afc0e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3370d2b63da2c87438a7d6da92afc0e5">&#9670;&nbsp;</a></span>interchange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::interchange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interchange (swap) the two loop levels <code>L0</code> and <code>L1</code>. </p>

</div>
</div>
<a id="a34d6e07e4f840d1c8d1ca74f925e3202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34d6e07e4f840d1c8d1ca74f925e3202">&#9670;&nbsp;</a></span>is_inline_computation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool tiramisu::computation::is_inline_computation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if and only if the computation is inline. </p>

</div>
</div>
<a id="a4bb92906d4541d1ab073bf9a164bc31c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bb92906d4541d1ab073bf9a164bc31c">&#9670;&nbsp;</a></span>mark_as_let_statement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::mark_as_let_statement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark this statement as a let statement. </p>

</div>
</div>
<a id="a2349d24241e2743e5fcdec1f2b70ff29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2349d24241e2743e5fcdec1f2b70ff29">&#9670;&nbsp;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiramisu_1_1expr.html">tiramisu::expr</a> tiramisu::computation::operator() </td>
          <td>(</td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access operator: C0(i,j) represents an access to the element (i,j) of the computation C0. </p>
<p>C0(i,j) represents the value computed by the computation C0(i,j) </p>

<p class="definition">Definition at line <a class="el" href="core_8h_source.html#l03273">3273</a> of file <a class="el" href="core_8h_source.html">core.h</a>.</p>

<p class="reference">References <a class="el" href="type_8h_source.html#l00107">tiramisu::o_access</a>, and <a class="el" href="classtiramisu_1_1expr.html#a90e4e26e7d53022edaccb26e082e793f">tiramisu::expr::substitute()</a>.</p>

</div>
</div>
<a id="a0c748331b7a5d0c111c1bb24928ec771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c748331b7a5d0c111c1bb24928ec771">&#9670;&nbsp;</a></span>parallelize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::parallelize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tag the loop level <code>L</code> to be parallelized. </p>
<p>This function is equivalent to the function tag_parallel_level(). There is no difference between the two. </p>

</div>
</div>
<a id="a7f412d1ba941c990f18225d43f0fb621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f412d1ba941c990f18225d43f0fb621">&#9670;&nbsp;</a></span>set_access() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::set_access </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>access_str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the access relation of the computation. </p>
<p>The access relation is a relation from computations to buffer locations. <code>access_str</code> is a string that represents the relation. It is encoded in the ISL format, <a href="http://isl.gforge.inria.fr/user.html#Sets-and-Relations">http://isl.gforge.inria.fr/user.html#Sets-and-Relations</a> of relations.</p>
<p>Note that, in TIramisu, the access relations of computation that have the same name must be identical.</p>
<p>Examples: tutorial_01, tutorial_02, tutorial_08 (actually most tutorials have <a class="el" href="classtiramisu_1_1computation.html#a7f412d1ba941c990f18225d43f0fb621" title="Set the access relation of the computation. ">set_access()</a>). </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorials_2tutorial_01_8cpp-example.html#a11">tutorials/tutorial_01.cpp</a>, <a class="el" href="tutorials_2tutorial_02_8cpp-example.html#a16">tutorials/tutorial_02.cpp</a>, <a class="el" href="tutorials_2tutorial_03_8cpp-example.html#a17">tutorials/tutorial_03.cpp</a>, <a class="el" href="tutorials_2tutorial_04_8cpp-example.html#a14">tutorials/tutorial_04.cpp</a>, <a class="el" href="tutorials_2tutorial_05_8cpp-example.html#a11">tutorials/tutorial_05.cpp</a>, and <a class="el" href="tutorials_2tutorial_06_8cpp-example.html#a16">tutorials/tutorial_06.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="a981e28763928d5faa066f9350b9547dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a981e28763928d5faa066f9350b9547dc">&#9670;&nbsp;</a></span>set_access() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::set_access </td>
          <td>(</td>
          <td class="paramtype">isl_map *&#160;</td>
          <td class="paramname"><em>access</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the access relation of the computation. </p>
<p>The access relation is a relation from computations to buffer locations. <code>access_str</code> is a string that represents the relation. It is encoded in the ISL format, <a href="http://isl.gforge.inria.fr/user.html#Sets-and-Relations">http://isl.gforge.inria.fr/user.html#Sets-and-Relations</a> of relations.</p>
<p>Note that, in TIramisu, the access relations of computation that have the same name must be identical.</p>
<p>Examples: tutorial_01, tutorial_02, tutorial_08 (actually most tutorials have <a class="el" href="classtiramisu_1_1computation.html#a7f412d1ba941c990f18225d43f0fb621" title="Set the access relation of the computation. ">set_access()</a>). </p>

</div>
</div>
<a id="abc5d65959a7499510d81a0bafe9a078d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc5d65959a7499510d81a0bafe9a078d">&#9670;&nbsp;</a></span>set_expression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::set_expression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtiramisu_1_1expr.html">tiramisu::expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the expression of the computation. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorials_2tutorial_03_8cpp-example.html#a10">tutorials/tutorial_03.cpp</a>, and <a class="el" href="tutorials_2tutorial_04_8cpp-example.html#a8">tutorials/tutorial_04.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="a1cca4650b13a542a52b12a300e35bc92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cca4650b13a542a52b12a300e35bc92">&#9670;&nbsp;</a></span>set_inline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::set_inline </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_inline</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets whether the computation is inline or not, based on the value of <code>is_inline</code>. </p>
<p>If a computation is inline, accesses to the computation return the expression of that computation. E.g. if an inline computation S(i,j) is defined with the expression i + j, then S(i + 1, j * i) returns the expression i + 1 + j * i. If <code>is_inline</code> is not provided, the computation is set to be inline. </p>

</div>
</div>
<a id="a73950403fb75df11351e34baa830c8e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73950403fb75df11351e34baa830c8e4">&#9670;&nbsp;</a></span>set_low_level_schedule() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::set_low_level_schedule </td>
          <td>(</td>
          <td class="paramtype">isl_map *&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the schedule indicated by <code>map</code>. </p>
<p><code>map</code> is a string that represents a mapping from the iteration domain to the time-space domain (the ISL format to represent maps is documented in <a href="http://barvinok.gforge.inria.fr/barvinok.pdf">http://barvinok.gforge.inria.fr/barvinok.pdf</a> in Sec 1.2.2).</p>
<p>The schedule is a map from the iteration domain to a time space domain. The same name of space should be used for both the range and the domain of the schedule.</p>
<p>In general, users can set the schedule using high level functions such as before(), after(), tile(), <a class="el" href="classtiramisu_1_1computation.html#ac2b2f3533b7bc2cdfd7adeb524fa6aa0" title="This function assumes that consumer consumes values produced by this computation (which is the produc...">compute_at()</a>, <a class="el" href="classtiramisu_1_1computation.html#abfb52d2e77fd1157343350a01fe905ab" title="Vectorize the loop level L. ">vectorize()</a>, split(), ... The use of this function is only reserved for advanced users who want a low level control of the schedule.</p>
<p>Vectors in the time-space domain have the following form</p>
<p>computation_name[redundancy_ID,static,dynamic,static,dynamic,static,dynamic,static,...]</p>
<p>The first dimension of the vector is used to indicate the redundancy ID (the notion of the redundancy ID is explained later).</p>
<p>The following dimensions are interleaved dimensions: static, dynamic, static, dynamic, ... Dynamic dimensions represent the loop levels, while static dimensions are used to order statements within a given block of statements in a given loop level. For example, the computations c0 and c1 in the following loop nest</p>
<p>for (i=0; i&lt;N: i++) for (j=0; j&lt;N; j++) { c0; c1; }</p>
<p>have the following representations in the iteration domain</p>
<p>{c0[i,j]: 0&lt;=i&lt;N and 0&lt;=j&lt;N} {c1[i,j]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}</p>
<p>and the following representation in the time-space domain</p>
<p>{c0[0,0,i,0,j,0]: 0&lt;=i&lt;N and 0&lt;=j&lt;N} {c1[0,0,i,0,j,1]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}</p>
<p>The first dimension (dimension 0) in the time-space domain (the leftmost dimension) is the redundancy ID (in this case it is 0, the meaning of this ID will be explained later). The second dimension (starting from the left) is a static dimension, the third dimension is a dynamic dimension that represents the loop level i, ..., the fifth dimension is a dynamic dimension that represents the loop level j and the last dimension (dimension 5) is a static dimension and allows the ordering of c1 after c0 in the loop nest.</p>
<p>To transform the previous iteration domain to the time-space domain, the following schedule should be used:</p>
<p>{c0[i,j]-&gt;c0[0,0,i,0,j,0]: 0&lt;=i&lt;N and 0&lt;=j&lt;N} {c1[i,j]-&gt;c1[0,0,i,0,j,1]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}</p>
<p>The first dimension called "redundancy ID" is only meaningful if the computation is redundant. i.e., some parts of the computation are redundantly computed. Redundant computations are in general used to maximize parallelism and data locality on the expense of doing some computations redundantly. For example, if the two computations c1(i,j) and c2(i,j) both depend on the computation c0(i,j), instead of waiting for c0(i,j) to be computed and then computing c1(i,j) and c2(i,j) in parallel, the thread executing c1(i,j) can compute c0(i,j) by itself and then run c1(i,j). The thread that computes c2(i,j) can do the same and compute c0(i,j) by itself and then compute c2(i,j). In this case the two threads do not need to wait. This is done at the expense of redundant computation since c0(i,j) is computed by both threads.</p>
<p>In general redundant computations are useful when tiling stencil computations. In the context of stencils such a tiling is called "overlapped tiling". Tiles that depend on results computed by other tiles that run in parallel can compute the boundaries redundantly which allows them to avoid waiting and thus can run in parallel.</p>
<p>In Tiramisu, the user can indicate that a chunk of a computation should be computed redundantly. The original computation always has a redundancy ID equal to 0 (which means this is the original computation). The redundant chunk has an ID that is different from 0 and that is used to uniquely identify it.</p>
<p>For example if we want to compute all of c0 three times (that is, compute the original computation and compute two redundant computations), we can use the following schedules:</p>
<p>The schedule of the original computation: {c0[i,j]-&gt;c0[0,0,i,0,j,0]: 0&lt;=i&lt;N and 0&lt;=j&lt;N} The schedule of the redundant computation N°1: {c0[i,j]-&gt;c0[1,0,i,0,j,0]: 0&lt;=i&lt;N and 0&lt;=j&lt;N} The schedule of the redundant computation N°2: {c0[i,j]-&gt;c0[2,0,i,0,j,0]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}</p>
<p>The schedule of c0 in this case would be three maps that map c0[i,j] to the three different redundant computations in the time-processor domain:</p>
<p>{c0[i,j]-&gt;c0[0,0,i,0,j,0]: 0&lt;=i&lt;N and 0&lt;=j&lt;N; c0[i,j]-&gt;c0[1,0,i,0,j,0]: 0&lt;=i&lt;N and 0&lt;=j&lt;N; c0[i,j]-&gt;c0[2,0,i,0,j,0]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}</p>
<p>The function set_schedule() overrides any other schedule set by the high level scheduling functions. Currently the user has to choose between using the high level scheduling functions or using this low level set_schedule function. The user cannot mix the use of the two in the same program because they are not compatible. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorials_2tutorial_04_8cpp-example.html#a9">tutorials/tutorial_04.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="a65cb781f866beb35776a60b7e8c095dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65cb781f866beb35776a60b7e8c095dc">&#9670;&nbsp;</a></span>set_low_level_schedule() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::set_low_level_schedule </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>map_str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the schedule indicated by <code>map</code>. </p>
<p><code>map</code> is a string that represents a mapping from the iteration domain to the time-space domain (the ISL format to represent maps is documented in <a href="http://barvinok.gforge.inria.fr/barvinok.pdf">http://barvinok.gforge.inria.fr/barvinok.pdf</a> in Sec 1.2.2).</p>
<p>The schedule is a map from the iteration domain to a time space domain. The same name of space should be used for both the range and the domain of the schedule.</p>
<p>In general, users can set the schedule using high level functions such as before(), after(), tile(), <a class="el" href="classtiramisu_1_1computation.html#ac2b2f3533b7bc2cdfd7adeb524fa6aa0" title="This function assumes that consumer consumes values produced by this computation (which is the produc...">compute_at()</a>, <a class="el" href="classtiramisu_1_1computation.html#abfb52d2e77fd1157343350a01fe905ab" title="Vectorize the loop level L. ">vectorize()</a>, split(), ... The use of this function is only reserved for advanced users who want a low level control of the schedule.</p>
<p>Vectors in the time-space domain have the following form</p>
<p>computation_name[redundancy_ID,static,dynamic,static,dynamic,static,dynamic,static,...]</p>
<p>The first dimension of the vector is used to indicate the redundancy ID (the notion of the redundancy ID is explained later).</p>
<p>The following dimensions are interleaved dimensions: static, dynamic, static, dynamic, ... Dynamic dimensions represent the loop levels, while static dimensions are used to order statements within a given block of statements in a given loop level. For example, the computations c0 and c1 in the following loop nest</p>
<p>for (i=0; i&lt;N: i++) for (j=0; j&lt;N; j++) { c0; c1; }</p>
<p>have the following representations in the iteration domain</p>
<p>{c0[i,j]: 0&lt;=i&lt;N and 0&lt;=j&lt;N} {c1[i,j]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}</p>
<p>and the following representation in the time-space domain</p>
<p>{c0[0,0,i,0,j,0]: 0&lt;=i&lt;N and 0&lt;=j&lt;N} {c1[0,0,i,0,j,1]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}</p>
<p>The first dimension (dimension 0) in the time-space domain (the leftmost dimension) is the redundancy ID (in this case it is 0, the meaning of this ID will be explained later). The second dimension (starting from the left) is a static dimension, the third dimension is a dynamic dimension that represents the loop level i, ..., the fifth dimension is a dynamic dimension that represents the loop level j and the last dimension (dimension 5) is a static dimension and allows the ordering of c1 after c0 in the loop nest.</p>
<p>To transform the previous iteration domain to the time-space domain, the following schedule should be used:</p>
<p>{c0[i,j]-&gt;c0[0,0,i,0,j,0]: 0&lt;=i&lt;N and 0&lt;=j&lt;N} {c1[i,j]-&gt;c1[0,0,i,0,j,1]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}</p>
<p>The first dimension called "redundancy ID" is only meaningful if the computation is redundant. i.e., some parts of the computation are redundantly computed. Redundant computations are in general used to maximize parallelism and data locality on the expense of doing some computations redundantly. For example, if the two computations c1(i,j) and c2(i,j) both depend on the computation c0(i,j), instead of waiting for c0(i,j) to be computed and then computing c1(i,j) and c2(i,j) in parallel, the thread executing c1(i,j) can compute c0(i,j) by itself and then run c1(i,j). The thread that computes c2(i,j) can do the same and compute c0(i,j) by itself and then compute c2(i,j). In this case the two threads do not need to wait. This is done at the expense of redundant computation since c0(i,j) is computed by both threads.</p>
<p>In general redundant computations are useful when tiling stencil computations. In the context of stencils such a tiling is called "overlapped tiling". Tiles that depend on results computed by other tiles that run in parallel can compute the boundaries redundantly which allows them to avoid waiting and thus can run in parallel.</p>
<p>In Tiramisu, the user can indicate that a chunk of a computation should be computed redundantly. The original computation always has a redundancy ID equal to 0 (which means this is the original computation). The redundant chunk has an ID that is different from 0 and that is used to uniquely identify it.</p>
<p>For example if we want to compute all of c0 three times (that is, compute the original computation and compute two redundant computations), we can use the following schedules:</p>
<p>The schedule of the original computation: {c0[i,j]-&gt;c0[0,0,i,0,j,0]: 0&lt;=i&lt;N and 0&lt;=j&lt;N} The schedule of the redundant computation N°1: {c0[i,j]-&gt;c0[1,0,i,0,j,0]: 0&lt;=i&lt;N and 0&lt;=j&lt;N} The schedule of the redundant computation N°2: {c0[i,j]-&gt;c0[2,0,i,0,j,0]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}</p>
<p>The schedule of c0 in this case would be three maps that map c0[i,j] to the three different redundant computations in the time-processor domain:</p>
<p>{c0[i,j]-&gt;c0[0,0,i,0,j,0]: 0&lt;=i&lt;N and 0&lt;=j&lt;N; c0[i,j]-&gt;c0[1,0,i,0,j,0]: 0&lt;=i&lt;N and 0&lt;=j&lt;N; c0[i,j]-&gt;c0[2,0,i,0,j,0]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}</p>
<p>The function set_schedule() overrides any other schedule set by the high level scheduling functions. Currently the user has to choose between using the high level scheduling functions or using this low level set_schedule function. The user cannot mix the use of the two in the same program because they are not compatible. </p>

</div>
</div>
<a id="a8e0c7011fba7e94bb836e7e5f1a55261"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e0c7011fba7e94bb836e7e5f1a55261">&#9670;&nbsp;</a></span>shift()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::shift </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shift the loop level <code>L0</code> of the iteration space by <code>n</code> iterations. </p>
<p><code>n</code> can be a positive or a negative number. A positive number means a shift forward of the loop iterations while a negative value would mean a shift backward. </p>

</div>
</div>
<a id="a71ba41faf9403d2db864c886db0301d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71ba41faf9403d2db864c886db0301d4">&#9670;&nbsp;</a></span>split() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeX</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the loop level <code>L0</code> of the iteration space into two new loop levels. </p>
<p><code>sizeX</code> is the extent (size) of the inner loop created after splitting. </p>

</div>
</div>
<a id="a6781ec005a7e9696b77f06d29d0d8e14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6781ec005a7e9696b77f06d29d0d8e14">&#9670;&nbsp;</a></span>split() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L0_outer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L0_inner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the loop level <code>L0</code> of the iteration space into two new loop levels. </p>
<p><code>sizeX</code> is the extent (size) of the inner loop created after splitting. </p>

</div>
</div>
<a id="a718678aa2f3dfddc06fbd6760db9c12f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a718678aa2f3dfddc06fbd6760db9c12f">&#9670;&nbsp;</a></span>storage_fold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::storage_fold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fold the storage of the computation. </p>
<p>Fold the loop level <code>dim</code> by a factor <code>f</code>. </p>

</div>
</div>
<a id="ab741d4c5e5dfd5bc0f079fdd681196da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab741d4c5e5dfd5bc0f079fdd681196da">&#9670;&nbsp;</a></span>store_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtiramisu_1_1computation.html">tiramisu::computation</a>* tiramisu::computation::store_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1computation.html">tiramisu::computation</a> &amp;&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate the storage of this computation in the loop level <code>L0</code>. </p>
<p>This function does the following:</p><ul>
<li>computes the size of the buffer needed to store this computation (TODO: current the size computed by Tiramisu is equal to the size of the computation, Tiramisu does not allocate smaller buffers if such a thing is possible, this is left for future work).</li>
<li>allocates a temporary buffer with the appropriate size,</li>
<li>schedules the allocation operation to be executed in the loop nest where <code>comp</code> is computated at the loop level <code>L0</code>.</li>
</ul>
<p>The function returns the computation (operation) that allocates the buffer. The allocated buffer is not returned. </p>

</div>
</div>
<a id="a12cf0a03413b4be996c62c1ea61f5d8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12cf0a03413b4be996c62c1ea61f5d8d">&#9670;&nbsp;</a></span>tag_gpu_level() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::tag_gpu_level </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tag the loop level <code>L0</code> and <code>L1</code> to be mapped to GPU. </p>

</div>
</div>
<a id="ae4fb03cd144ca7282b5fbcf3a5aeb32e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4fb03cd144ca7282b5fbcf3a5aeb32e">&#9670;&nbsp;</a></span>tag_gpu_level() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::tag_gpu_level </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tag the loop level <code>L0</code> and <code>L1</code> to be mapped to GPU. </p>

</div>
</div>
<a id="ab21a3469f5925d109b1f850ea9a9dd57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab21a3469f5925d109b1f850ea9a9dd57">&#9670;&nbsp;</a></span>tag_gpu_level() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::tag_gpu_level </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L5</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tag the loop level <code>L0</code> and <code>L1</code> to be mapped to GPU. </p>

</div>
</div>
<a id="a37ba81bf0611bb2f058ae7659fefd561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37ba81bf0611bb2f058ae7659fefd561">&#9670;&nbsp;</a></span>tag_parallel_level()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::tag_parallel_level </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tag the loop level <code>L</code> to be parallelized. </p>

</div>
</div>
<a id="a2ab7d0d28bfc5cef46d45483bc1c6385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ab7d0d28bfc5cef46d45483bc1c6385">&#9670;&nbsp;</a></span>tag_unroll_level()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::tag_unroll_level </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tag the loop level <code>L</code> to be unrolled. </p>
<p>The user can only tag loop levels that have constant extent. </p>

</div>
</div>
<a id="a6b1c88a897e6ebd7c6e9b7bf0a35c963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b1c88a897e6ebd7c6e9b7bf0a35c963">&#9670;&nbsp;</a></span>tag_vector_level()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::tag_vector_level </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tag the loop level <code>L</code> to be vectorized. </p>
<p><code>len</code> is the vector length.</p>
<p>The user can only tag loop levels that have constant extent. If a loop level does not have a constant extent, the user should call .<a class="el" href="classtiramisu_1_1computation.html#abfb52d2e77fd1157343350a01fe905ab" title="Vectorize the loop level L. ">vectorize()</a> command instead or he can call separate() and split() manually.</p>
<p>The user has to make sure that the extent of the dimension is bigger than <code>len</code>. The vectorization of a loop that has less than <code>len</code> iterations is not correct. </p>

</div>
</div>
<a id="a0fc402b23a4d138cd21eda8e041a8a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fc402b23a4d138cd21eda8e041a8a03">&#9670;&nbsp;</a></span>tile() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::tile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tile the two loop levels <code>L0</code> and <code>L1</code> with rectangular tiling. </p>
<p><code>sizeX</code> and <code>sizeY</code> represent the tile size. <code>L0</code> and <code>L1</code> should be two consecutive loop levels. <code>L0_outer</code>, <code>L1_outer</code>, <code>L0_inner</code>, <code>L1_inner</code> are the names of the new dimensions created after tiling. </p>

</div>
</div>
<a id="a5a63c66e3db24bd85b1ffe7b23822c6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a63c66e3db24bd85b1ffe7b23822c6c">&#9670;&nbsp;</a></span>tile() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::tile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L0_outer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L1_outer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L0_inner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L1_inner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tile the two loop levels <code>L0</code> and <code>L1</code> with rectangular tiling. </p>
<p><code>sizeX</code> and <code>sizeY</code> represent the tile size. <code>L0</code> and <code>L1</code> should be two consecutive loop levels. <code>L0_outer</code>, <code>L1_outer</code>, <code>L0_inner</code>, <code>L1_inner</code> are the names of the new dimensions created after tiling. </p>

</div>
</div>
<a id="ae37bc997ad3dacfd4bea812c068b87ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae37bc997ad3dacfd4bea812c068b87ff">&#9670;&nbsp;</a></span>tile() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::tile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeZ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tile the two loop levels <code>L0</code> and <code>L1</code> with rectangular tiling. </p>
<p><code>sizeX</code> and <code>sizeY</code> represent the tile size. <code>L0</code> and <code>L1</code> should be two consecutive loop levels. <code>L0_outer</code>, <code>L1_outer</code>, <code>L0_inner</code>, <code>L1_inner</code> are the names of the new dimensions created after tiling. </p>

</div>
</div>
<a id="a8b17318417cb0d0419f66bf8fb742246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b17318417cb0d0419f66bf8fb742246">&#9670;&nbsp;</a></span>tile() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::tile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L0_outer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L1_outer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L2_outer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L0_inner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L1_inner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L2_inner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tile the two loop levels <code>L0</code> and <code>L1</code> with rectangular tiling. </p>
<p><code>sizeX</code> and <code>sizeY</code> represent the tile size. <code>L0</code> and <code>L1</code> should be two consecutive loop levels. <code>L0_outer</code>, <code>L1_outer</code>, <code>L0_inner</code>, <code>L1_inner</code> are the names of the new dimensions created after tiling. </p>

</div>
</div>
<a id="a68cc2dc757dfb181548b739c901ed6f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68cc2dc757dfb181548b739c901ed6f9">&#9670;&nbsp;</a></span>unroll() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::unroll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fac</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unroll the loop level <code>L</code> with an unrolling factor <code>fac</code>. </p>
<p>The difference between this function and the function tag_unroll_level() is that this function separates the iteration domain into full and partial iteration domains for unrolling first and then it calls tag_unroll_level(). tag_unroll_level() only tags a dimension to be unrolled, it does not modify the tagged dimension.</p>
<p>This function separates the iteration domain into two iteration domains, a full iteration domain and a partial iteration domain. The full iteration domain has an upper bound that is multiple of <code>fac</code> while the other does not. The full iteration domain is then split by <code>fac</code> and the inner loop (which should have a constant extent equal to <code>fac</code>) is tagged as a unrolled loop.</p>
<p>Let us assume the following loop (a loop represents and iteration domain)</p>
<p>for (i=0; i&lt;N; i++) for (j=0; j&lt;23; j++) S0;</p>
<p>To unroll the j loop with an unrolling factor of 4, one should call </p><pre class="fragment"> S0.unroll(j, 4);
</pre><p>The loop (iteration domain) is first separated into the following two loops</p>
<p>for (int i=0; i&lt;20; i++) S0;</p>
<p>for (int i=20; i&lt;23; i++) S0;</p>
<p>The full loop is then split by 4</p>
<p>for (int i1=0; i1&lt;20/4; i1++) for (int i2=0; i2&lt;4; i2++) S0;</p>
<p>for (int i=20; i&lt;23; i++) S0;</p>
<p>the i2 loop is then tagged to be unrolled.</p>
<p><code>L_outer</code> and <code>L_inner</code> are the names of the new loops created after splitting. If not provided, default names will be assigned. <code>L_outer</code> is the outer loop. </p>

</div>
</div>
<a id="a566d1284eef9d999112660a3fff30561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a566d1284eef9d999112660a3fff30561">&#9670;&nbsp;</a></span>unroll() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::unroll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L_outer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L_inner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unroll the loop level <code>L</code> with an unrolling factor <code>fac</code>. </p>
<p>The difference between this function and the function tag_unroll_level() is that this function separates the iteration domain into full and partial iteration domains for unrolling first and then it calls tag_unroll_level(). tag_unroll_level() only tags a dimension to be unrolled, it does not modify the tagged dimension.</p>
<p>This function separates the iteration domain into two iteration domains, a full iteration domain and a partial iteration domain. The full iteration domain has an upper bound that is multiple of <code>fac</code> while the other does not. The full iteration domain is then split by <code>fac</code> and the inner loop (which should have a constant extent equal to <code>fac</code>) is tagged as a unrolled loop.</p>
<p>Let us assume the following loop (a loop represents and iteration domain)</p>
<p>for (i=0; i&lt;N; i++) for (j=0; j&lt;23; j++) S0;</p>
<p>To unroll the j loop with an unrolling factor of 4, one should call </p><pre class="fragment"> S0.unroll(j, 4);
</pre><p>The loop (iteration domain) is first separated into the following two loops</p>
<p>for (int i=0; i&lt;20; i++) S0;</p>
<p>for (int i=20; i&lt;23; i++) S0;</p>
<p>The full loop is then split by 4</p>
<p>for (int i1=0; i1&lt;20/4; i1++) for (int i2=0; i2&lt;4; i2++) S0;</p>
<p>for (int i=20; i&lt;23; i++) S0;</p>
<p>the i2 loop is then tagged to be unrolled.</p>
<p><code>L_outer</code> and <code>L_inner</code> are the names of the new loops created after splitting. If not provided, default names will be assigned. <code>L_outer</code> is the outer loop. </p>

</div>
</div>
<a id="abfb52d2e77fd1157343350a01fe905ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfb52d2e77fd1157343350a01fe905ab">&#9670;&nbsp;</a></span>vectorize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::vectorize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vectorize the loop level <code>L</code>. </p>
<p>Use the vector length <code>v</code>.</p>
<p>The difference between this function and the function tag_vector_level() is that this function prepares the iteration domain for vectorization first and then it calls tag_vector_level(). tag_vector_level() only tags a dimension to be vectorized, it does not change the tagged dimension.</p>
<p>This function will separate the iteration domain into two iteration domains, a full iteration domain and a partial iteration domain. The full iteration domain has an upper bound that is multiple of <code>v</code> while the other does not. The full iteration domain is then split by <code>v</code> and the inner loop (which should have a constant extent equal to <code>v</code>) is tagged as a vector loop.</p>
<p>Let us assume the following loop (a loop represents and iteration domain)</p>
<p>for (i=0; i&lt;N; i++) for (j=0; j&lt;23; j++) S0;</p>
<p>To vectorize the j loop with a vector length 4, one should call </p><pre class="fragment"> S0.vectorize(j, 4);
</pre><p>The loop (iteration domain) is first separated into the following two loops</p>
<p>for (int i=0; i&lt;20; i++) S0;</p>
<p>for (int i=20; i&lt;23; i++) S0;</p>
<p>The full loop is then split by 4</p>
<p>for (int i1=0; i1&lt;20/4; i1++) for (int i2=0; i2&lt;4; i2++) S0;</p>
<p>for (int i=20; i&lt;23; i++) S0;</p>
<p>the i2 loop is then tagged to be vectorized.</p>
<p>The user has to make sure that the extent of the dimension is bigger than <code>v</code>. The vectorization of a loop that has less than <code>v</code> iterations is not correct.</p>
<p>The names of the new loop iterators created after vectorization are <code>L_outer</code> and <code>L_inner</code>. If not provided, default names assigned. </p>

</div>
</div>
<a id="ac7f4dd685fd931af56ba633fef4b184b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7f4dd685fd931af56ba633fef4b184b">&#9670;&nbsp;</a></span>vectorize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tiramisu::computation::vectorize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L_outer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtiramisu_1_1var.html">tiramisu::var</a>&#160;</td>
          <td class="paramname"><em>L_inner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vectorize the loop level <code>L</code>. </p>
<p>Use the vector length <code>v</code>.</p>
<p>The difference between this function and the function tag_vector_level() is that this function prepares the iteration domain for vectorization first and then it calls tag_vector_level(). tag_vector_level() only tags a dimension to be vectorized, it does not change the tagged dimension.</p>
<p>This function will separate the iteration domain into two iteration domains, a full iteration domain and a partial iteration domain. The full iteration domain has an upper bound that is multiple of <code>v</code> while the other does not. The full iteration domain is then split by <code>v</code> and the inner loop (which should have a constant extent equal to <code>v</code>) is tagged as a vector loop.</p>
<p>Let us assume the following loop (a loop represents and iteration domain)</p>
<p>for (i=0; i&lt;N; i++) for (j=0; j&lt;23; j++) S0;</p>
<p>To vectorize the j loop with a vector length 4, one should call </p><pre class="fragment"> S0.vectorize(j, 4);
</pre><p>The loop (iteration domain) is first separated into the following two loops</p>
<p>for (int i=0; i&lt;20; i++) S0;</p>
<p>for (int i=20; i&lt;23; i++) S0;</p>
<p>The full loop is then split by 4</p>
<p>for (int i1=0; i1&lt;20/4; i1++) for (int i2=0; i2&lt;4; i2++) S0;</p>
<p>for (int i=20; i&lt;23; i++) S0;</p>
<p>the i2 loop is then tagged to be vectorized.</p>
<p>The user has to make sure that the extent of the dimension is bigger than <code>v</code>. The vectorization of a loop that has less than <code>v</code> iterations is not correct.</p>
<p>The names of the new loop iterators created after vectorization are <code>L_outer</code> and <code>L_inner</code>. If not provided, default names assigned. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a7b874384f567f7bbf60bbf58f86e6ddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b874384f567f7bbf60bbf58f86e6ddc">&#9670;&nbsp;</a></span>root</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtiramisu_1_1var.html">var</a> tiramisu::computation::root</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>root_dimension is a number used to specify the dimension level known as root. </p>
<p>The root dimension level is the outermost level. It is the level outside any loop nest. Loop level 0 is the level of the first loop (outermost loop), loop 1 is the level of following inner loop, ...</p>
<p>Where is this number used ?</p>
<p>These numbers are used in the helper functions used for scheduling (such as after(), before(), ...). For example, c0.after(c1) indicates that the computation c0 should be executed after the computation c1. Since the two computations c0 and c1 are usually nested in a loop, we need to specify at which loop level c0 is after c1. This is where we need to specify the loop level numbers. Here is an example. Suppose that the two computations c0 and c1 have the following iteration domains {c0[i,j]: 0&lt;=i&lt;N and 0&lt;=j&lt;N} and {c1[i,j]: 0&lt;=i&lt;N and 0&lt;=j&lt;N}.</p>
<p>When code is generated for the two computations, two loop nests are generated. When scheduling c0 after c1 using the after function, the user can choose one among three possibilities in specifying at which level c0 is after c1.</p>
<ul>
<li>c0.after(c1, computation::root_dimension) would create a schedule that generates the following code</li>
</ul>
<p>for (i=0; i&lt;N; i++) for (j=0; j&lt;N; j++) c1; for (i=0; i&lt;N; i++) for (j=0; j&lt;N; j++) c0;</p>
<ul>
<li>c0.after(c1, 0) would create a schedule that generates the following code</li>
</ul>
<p>for (i=0; i&lt;N; i++) { for (j=0; j&lt;N; j++) c1; for (j=0; j&lt;N; j++) c0; }</p>
<p>This means that c0 is after c1 starting from loop level 0, (before the loop level 0, c0 and c1 have the same order).</p>
<ul>
<li>c0.after(c1, 1) would create a schedule that generates the following code</li>
</ul>
<p>for (i=0; i&lt;N; i++) for (j=0; j&lt;N; j++) { c1; c0; }</p>
<p>This means that c0 is after c1 starting from loop level 1, (before the loop level 1, c0 and c1 have the same order). </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorials_2tutorial_02_8cpp-example.html#a11">tutorials/tutorial_02.cpp</a>, and <a class="el" href="tutorials_2tutorial_06_8cpp-example.html#a12">tutorials/tutorial_06.cpp</a>.</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="core_8h_source.html#l03258">3258</a> of file <a class="el" href="core_8h_source.html">core.h</a>.</p>

</div>
</div>
<a id="ab8e56982ea734feb3dc1670969ff617d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8e56982ea734feb3dc1670969ff617d">&#9670;&nbsp;</a></span>root_dimension</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int tiramisu::computation::root_dimension = -1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent of <a class="el" href="classtiramisu_1_1computation.html#a7b874384f567f7bbf60bbf58f86e6ddc" title="root_dimension is a number used to specify the dimension level known as root. ">computation::root</a> but to be used with scheduling functions that take loop level (integers) as input instead of <a class="el" href="classtiramisu_1_1var.html" title="A class that represents constant variable references. ">tiramisu::var</a>. </p>

<p class="definition">Definition at line <a class="el" href="core_8h_source.html#l03265">3265</a> of file <a class="el" href="core_8h_source.html">core.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="core_8h_source.html">core.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacetiramisu.html">tiramisu</a></li><li class="navelem"><a class="el" href="classtiramisu_1_1computation.html">computation</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
